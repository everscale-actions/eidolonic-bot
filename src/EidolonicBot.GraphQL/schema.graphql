schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

type Query {
    "Flex API"
    flex("Default address is the latest Super Root" superRoot: String "Default is `releaseConfig` address of superRoot.\nIf superRoot is omitted and globalConfig is specified, then all flex data\nwill be related to globalConfig except FlexQuery root fields related\nto Super root (releaseConfig, betaConfig, etc)" globalConfig: String): FlexQuery!
    "Statistics API"
    statistics: StatisticsQuery!
    "FT API"
    ft: FungibleTokenQuery!
    info: Info
    "Blockchain-related information (blocks, transactions, etc.)"
    blockchain: BlockchainQuery
    accounts(filter: AccountFilter orderBy: [QueryOrderBy] limit: Int timeout: Float): [Account]
    transactions(filter: TransactionFilter orderBy: [QueryOrderBy] limit: Int timeout: Float): [Transaction]
    messages(filter: MessageFilter orderBy: [QueryOrderBy] limit: Int timeout: Float): [Message]
    blocks(filter: BlockFilter orderBy: [QueryOrderBy] limit: Int timeout: Float): [Block]
    blocks_signatures(filter: BlockSignaturesFilter orderBy: [QueryOrderBy] limit: Int timeout: Float): [BlockSignatures]
    zerostates(filter: ZerostateFilter orderBy: [QueryOrderBy] limit: Int timeout: Float): [Zerostate]
    "Returns account counterparties"
    counterparties("Account address" account: String! "Portion size" first: Int "Starting cursor" after: String): [Counterparty]
    "Compute aggregated values for specified fields\n\nComplexity 100"
    aggregateAccounts("Specify filter for records to aggregate" filter: AccountFilter "Specify list of fields to collect aggregated values" fields: [FieldAggregation]): [String]
    "Compute aggregated values for specified fields\n\nComplexity 100"
    aggregateTransactions("Specify filter for records to aggregate" filter: TransactionFilter "Specify list of fields to collect aggregated values" fields: [FieldAggregation]): [String]
    "Compute aggregated values for specified fields\n\nComplexity 100"
    aggregateMessages("Specify filter for records to aggregate" filter: MessageFilter "Specify list of fields to collect aggregated values" fields: [FieldAggregation]): [String]
    "Compute aggregated values for specified fields\n\nComplexity 100"
    aggregateBlocks("Specify filter for records to aggregate" filter: BlockFilter "Specify list of fields to collect aggregated values" fields: [FieldAggregation]): [String]
    "Compute aggregated values for specified fields\n\nComplexity 100"
    aggregateBlockSignatures("Specify filter for records to aggregate" filter: BlockSignaturesFilter "Specify list of fields to collect aggregated values" fields: [FieldAggregation]): [String]
    "Version of the service that exposes recentExtInMessageStatuses query and\nrecentExtInMessageStatuses subscription\n\nComplexity 0"
    messageMonitorVersion: String!
    "Returns current processing status for each message.\nReturns the result transaction if the message was successfully processed, in case of TIMEOUT\ntries to return the result of transaction emulation."
    recentExtInMessageStatuses(messages: [MessageMonitoringParams!]!): [MessageMonitoringResult!]!
    cost(dryRun: Boolean): Cost
    price: Price!
}

type Subscription {
    flexMarketRecentTrades(superRoot: String globalConfig: String pairAddress: String pairTicker: String after: String): [FlexTrade!]!
    flexMarketOrderBook(superRoot: String globalConfig: String pairAddress: String pairTicker: String): FlexOrderBook!
    flexMarketPriceHistory(superRoot: String globalConfig: String pairAddress: String pairTicker: String "Resolution in seconds.\nTo determine available resolutions you have to request market.priceHistoryResolutions" resolution: Int "Starting time for price history.\nInclusive. Specified in UNIX timestamp.\n\nIf this field is omitted then the `countBack` parameter will be used." startTime: Int "Defines minimum number of returned prices, and has priority over `startTime` parameter,\ni.e. you must return data in the range `[from, to)`, but the number of prices\nshould not be less than `countBack`." countBack: Int): [FlexPriceSummary!]!
    flexUserOrders(superRoot: String globalConfig: String "User id." userId: String!): [FlexUserOrder!]!
    flexUserTrades(superRoot: String globalConfig: String "User id." userId: String! after: String): [FlexUserTrade!]!
    flexWallets(superRoot: String globalConfig: String clientAddress: String! "Token filter." token: String "User id filter." userId: String "DApp public key filter." dappPubkey: String "Optional sunscription starting cursor." after: String): [FlexWallet!]!
    accounts(filter: AccountFilter): Account
    transactions(filter: TransactionFilter): Transaction
    messages(filter: MessageFilter): Message
    blocks(filter: BlockFilter): Block
    blocks_signatures(filter: BlockSignaturesFilter): BlockSignatures
    zerostates(filter: ZerostateFilter): Zerostate
    counterparties(filter: CounterpartyFilter): Counterparty
    rempReceipts(messageId: String!): RempReceipt
    "Subscribes for message processing results.\nUser will receive exactly one result per each message."
    recentExtInMessageStatuses(messages: [MessageMonitoringParams!]!): MessageMonitoringResult!
}

"\nComplexity 0"
type FlexExchangeConfig {
    "Version of exchange contracts (flex, pair, price)\n\nComplexity 0"
    version: Int
    "Fees configuration"
    fees: FlexFeesConfig
}

"\nComplexity 0"
type FlexFeesConfig {
    "For executing tip3 transfer\n\nComplexity 0"
    transferTip3: String
    "To return tip3 ownership\n\nComplexity 0"
    returnOwnership: String
    "To send answer message from PriceXchg\n\nComplexity 0"
    orderAnswer: String
    "To process processQueue function.\nAlso is used for buyTip3 \/ onTip3LendOwnership \/ cancelSell \/ cancelBuy estimations.\n\nComplexity 0"
    processQueue: String
    "To send notification about completed deals (IFlexNotify)\n\nComplexity 0"
    sendNotify: String
    "Amount of EVERs transferred to the recipient tip3 wallet during all token transfers.\nNeeded to support wallet auto-deploy, so that the deployed wallet has enough funds\nto process. Auto-deploy happens when tokens are transferred to a not existing wallet.\n\nComplexity 0"
    destWalletKeepEvers: String
}

"\nComplexity 0"
type FlexGlobalConfig {
    "Global config address\n\nComplexity 0"
    address: String
    "Wallet, Exchange and User versions structure"
    version: FlexGlobalConfigVersion
    "Exchange Group version info"
    exchange: FlexExchangeConfig
    "Wrapper config"
    wrapper: FlexWrapperConfig
    "User config"
    user: FlexUserConfig
}

"\nComplexity 0"
type FlexGlobalConfigVersion {
    "Version of token wrappers and wallets contracts\n\nComplexity 0"
    wallet: Int
    "Version of exchange contracts (flex, pair, price)\n\nComplexity 0"
    exchange: Int
    "Version of user contracts and debots (FlexClient, etc)\n\nComplexity 0"
    user: Int
}

"\nComplexity 10"
type FlexMarketQuery {
    "Tokens pair"
    pair: FlexPair
    "Recent trades"
    recentTrades(limit: Int after: String): [FlexTrade!]!
    "Price history resolutions.\nEach resolution represented in seconds.\n\nComplexity 0"
    priceHistoryResolutions: [Int!]!
    "Price history."
    priceHistory("Resolution in seconds.\nTo determine available resolutions you have to request market.priceHistoryResolutions" resolution: Int "Starting time for price history.\nInclusive. Specified in UNIX timestamp.\n\nIf this field is omitted then the `countBack` parameter will be used." startTime: Int "Ending time for price history.\nExclusive. Specified in UNIX timestamp.\n\nIf this parameter is omitted then the current server time will be used." endTime: Int "Defines minimum number of returned prices, and has priority over `startTime` parameter,\ni.e. you must return data in the range `[from, to)`, but the number of prices\nshould not be less than `countBack`." countBack: Int): FlexPriceHistory!
    "Order book."
    orderBook("Maximum number or bids and asks." limit: Int): FlexOrderBook!
    "Market price history for the last 24 hours"
    last24H: FlexPriceSummary!
    "Market price\n\nComplexity 0"
    price: String
}

"\nComplexity 10"
type FlexOrderBook {
    "Buys"
    bids: [FlexOrderBookItem!]!
    "Sells"
    asks: [FlexOrderBookItem!]!
}

"Market price summary for time range\n\nComplexity 0"
type FlexOrderBookItem {
    "Token price numerator\n\nComplexity 0"
    priceNum: String
    "Token price denominator\n\nComplexity 0"
    priceScale: String
    "Unit price denominator\n\nComplexity 0"
    priceScaleUnits: String
    "Major token price\n\nComplexity 0"
    price: String
    "\nComplexity 0"
    amount: String
    "\nComplexity 0"
    amountUnits: String
}

"\nComplexity 10"
type FlexPair {
    "Flex Pair account address\n\nComplexity 0"
    address: String
    "Abbreviation used to identify pair.\nDerived from major and minor root tickers, i.e. 'EVER\/SOL'\n\nComplexity 0"
    ticker: String
    "Major token"
    major: FlexToken
    "Minor token"
    minor: FlexToken
    "\nComplexity 0"
    minAmountUnits: String
    "Price tick size numerator\n\nComplexity 0"
    minMove: String
    "Token price denominator\n\nComplexity 0"
    priceScale: String
    "Unit price denominator\n\nComplexity 0"
    priceScaleUnits: String
    "Code hash of price contracts for the pair\n\nComplexity 0"
    priceCodeHash: String
    "Price contracts code BOC encoded with base64\n\nComplexity 0"
    priceCode: String
    "Notification contract address\n\nComplexity 0"
    notifyAddress: String
    "Minimum amount of major token required for an order creation\nin token units.\n\nComplexity 0"
    minAmount: String
}

"\nComplexity 200"
type FlexPriceHistory {
    "Prices"
    prices: [FlexPriceSummary!]!
    "Returns next available time before the requested time range.\nReturns null if there is no more prices.\n\nComplexity 0"
    nextTime: Int
}

"Market price summary for time range\n\nComplexity 5"
type FlexPriceSummary {
    "Range start time.\nRange end time is `time` + `resolution`\n\nComplexity 0"
    time: Int
    "The first price in range (opening price)\n\nComplexity 0"
    open: String
    "The last price in range (closing price)\n\nComplexity 0"
    close: String
    "Minimal price in range\n\nComplexity 0"
    low: String
    "Maximal price in range\n\nComplexity 0"
    high: String
    "Total amount of all trades in range\n\nComplexity 0"
    volume: String
}

"\nComplexity 0"
type FlexQuery {
    "FLEX API version\n\nComplexity 0"
    version: String!
    "Super Root address\n\nComplexity 0"
    address: String!
    "Super Root version\n\nComplexity 0"
    revision: Int
    "Flag that indicates that a bug was found in Exchange contracts,\nyou should stop trading and cancel all your orders.\nKeep funds on your wallets, they are okay.\n\nComplexity 0"
    stopTrade: Boolean
    "Flag that indicates that a bug was found that encourages everyone\nto cancel their orders and withdraw their funds from Flex wallets asap\n\nComplexity 0"
    abandonShip: Boolean
    "`True` means the beginning of upgrade process which forbids to list\/unlist\nnew wrappers and pairs. Flag is reset to false when upgrade process is over.\n`False` means the dex is not in the upgrade process and one can list\/unlist\nnew wrappers and pairs.\n\nComplexity 0"
    updateStarted: Boolean
    "Current global config"
    config: FlexGlobalConfig!
    "Flex release version from Super Root"
    releaseConfig: FlexGlobalConfig
    "Flex beta version from Super Root"
    betaConfig: FlexGlobalConfig
    "Returns Flex Tokens"
    tokens(tickerSubstringFilter: String limit: Int offset: Int): [FlexToken!]!
    "Returns Flex Token"
    getToken(ticker: String address: String): FlexToken
    "Returns Flex Token Pairs"
    pairs(tickerSubstringFilter: String limit: Int offset: Int): [FlexPair!]!
    "Returns Flex Pair"
    getPair(ticker: String address: String): FlexPair
    "Flex market related to specified token's pair"
    market(pairTicker: String pairAddress: String): FlexMarketQuery!
    "Flex client wallet's"
    wallets(clientAddress: String! token: String userId: String dappPubkey: String after: String limit: Int): [FlexWallet!]!
    "Flex user trades"
    userTrades(userId: String! after: String limit: Int): [FlexUserTrade!]!
    "Flex user orders"
    userOrders(userId: String!): [FlexUserOrder!]!
}

"\nComplexity 10"
type FlexToken {
    "Flex Tip3 root address (wrapper address)\n\nComplexity 0"
    address: String
    "Token ticker, i.e. 'EVER'\n\nComplexity 0"
    ticker: String
    "Full name\n\nComplexity 0"
    name: String
    "Number of decimal places\n\nComplexity 0"
    decimals: Int
    "Total allocated and granted tokens (in token units).\n\nComplexity 0"
    totalAllocatedUnits: String
    "Flex wallet code hash\n\nComplexity 0"
    walletCodeHash: String
    "Type of the wrapper account\n\nComplexity 0"
    wrapperType: Int
    "Wrapper account that locks and stores all external tokens\n\nComplexity 0"
    externalAddress: String
    "Wallet that receives maker fees\n\nComplexity 0"
    reserveWallet: String
    "Total allocated and granted tokens (in tokens).\n\nComplexity 0"
    totalAllocated: String
}

"\nComplexity 5"
type FlexTrade {
    "Determines the type of the later order (taker) in trade."
    side: FlexTradeSide
    "Trade time as a unix time stamp\n\nComplexity 0"
    time: Int
    "Sold token"
    sellToken: FlexToken
    "Bought token"
    buyToken: FlexToken
    "Price numerator\n\nComplexity 0"
    priceNum: String
    "Token price denominator\n\nComplexity 0"
    priceScale: String
    "Unit price denominator\n\nComplexity 0"
    priceScaleUnits: String
    "\nComplexity 0"
    amountUnits: String
    "Price of the major token in tokens\n\nComplexity 0"
    price: String
    "Amount of the major tokens in tokens\n\nComplexity 0"
    amount: String
    "\nComplexity 0"
    cursor: String
}

enum FlexTradeLiquidity {
    TAKER
    MAKER
}

enum FlexTradeSide {
    BUY
    SELL
}

"\nComplexity 2"
type FlexUserConfig {
    "Version\n\nComplexity 0"
    version: Int
}

"Market price summary for time range\n\nComplexity 5"
type FlexUserOrder {
    "Flex market (pair)"
    pair: FlexPair
    "Determines the type of the order"
    side: FlexTradeSide
    "Amount of the major token units left\n\nComplexity 0"
    amountLeftUnits: String
    "Amount of the major token units processed\n\nComplexity 0"
    amountProcessedUnits: String
    "Price numerator\n\nComplexity 0"
    priceNum: String
    "Token price denominator\n\nComplexity 0"
    priceScale: String
    "Unit price denominator\n\nComplexity 0"
    priceScaleUnits: String
    "Finish time\n\nComplexity 0"
    finishTime: Int
    "User id\n\nComplexity 0"
    userId: String
    "Order id\n\nComplexity 0"
    orderId: String
    "Price of the major token in minor tokens\n\nComplexity 0"
    price: String
    "Amount of the major tokens left\n\nComplexity 0"
    amountLeft: String
    "Amount of the major tokens processed\n\nComplexity 0"
    amountProcessed: String
}

"\nComplexity 5"
type FlexUserTrade {
    "Flex market (pair)"
    pair: FlexPair
    "Price numerator\n\nComplexity 0"
    priceNum: String
    "Token price denominator\n\nComplexity 0"
    priceScale: String
    "Unit price denominator\n\nComplexity 0"
    priceScaleUnits: String
    "Amount of the major units\n\nComplexity 0"
    amountUnits: String
    "Trade time as a unix time stamp\n\nComplexity 0"
    time: Int
    "Determines the type of the later order (taker) in trade."
    side: FlexTradeSide
    "Determines the users position in trade. Maker or taker.\nMaker is a trade counterparty whose order was earlier.\nTaker is a counterparty with a later order."
    liquidity: FlexTradeLiquidity
    "User fees in `fees_token` units.\n\nComplexity 0"
    feesUnits: String
    "User fees token."
    feesToken: FlexToken
    "User's order id.\n\nComplexity 0"
    userOrderId: String
    "Token price denominator\n\nComplexity 0"
    price: String
    "Amount of the major tokens\n\nComplexity 0"
    amount: String
    "User fees for this trade. Measured in major tokens.\n\nIf the user is a maker then fees is a value\nreceived by user as a bonus for making order.\nNote that in this case the fees is a negative value.\n\nIf the user is a taker then fees is a value that\nthe user pays to the exchange and maker.\n\nComplexity 0"
    fees: String
    "\nComplexity 0"
    cursor: String
}

"\nComplexity 10"
type FlexWallet {
    "Flex wallet address\n\nComplexity 0"
    address: String
    "Flex client account address\n\nComplexity 0"
    clientAddress: String
    "User id the account owner\n\nComplexity 0"
    userId: String
    "Dapp public key\n\nComplexity 0"
    dappPubkey: String
    "Wallet token"
    token: FlexToken
    "Balance of native currency of the wallet (in nano EVERs)\n\nComplexity 0"
    nativeCurrencyBalanceUnits: String
    "Token balance of the wallet in units\n\nComplexity 0"
    totalBalanceUnits: String
    "Available balance in units\n\nComplexity 0"
    availableBalanceUnits: String
    "Balance in orders in units\n\nComplexity 0"
    balanceInOrdersUnits: String
    "Unsalted price code hash\n\nComplexity 0"
    unsaltedPriceCodeHash: String
    "Option indicating that this wallet was deleted.\nNow this option is always `false` if the wallet is returned by `userWallets` query.\nIn subscriptions this option can have value `true` if wallet was deleted.\n\nComplexity 0"
    deleted: Boolean
    "Balance of native currency of the wallet in EVERs\n\nComplexity 0"
    nativeCurrencyBalance: String
    "Token balance of the wallet in tokens\n\nComplexity 0"
    totalBalance: String
    "Available balance in tokens\n\nComplexity 0"
    availableBalance: String
    "Balance in orders\n\nComplexity 0"
    balanceInOrders: String
    "\nComplexity 0"
    cursor: String
}

"\nComplexity 2"
type FlexWrapperConfig {
    "Version\n\nComplexity 0"
    version: Int
}

"\nComplexity 100"
type AccountsStatisticsQuery {
    "Count of all accounts\n\nComplexity 0"
    totalCount: Int
    "Count of active accounts\n\nComplexity 0"
    totalActiveCount: Int
    "Network total supply\n\nComplexity 0"
    totalSupply: String
    "Remaining tokens amount on givers\n\nComplexity 0"
    amountOnGivers: String
    "Circulating supply TON\n\nComplexity 0"
    circulatingSupply: String
    "New accounts in 24 hours\n\nComplexity 0"
    lastDayCount: Int
    "Count of different contract code hashes deployed\n\nComplexity 0"
    accountTypesCount: Int
}

"\nComplexity 100"
type BlocksStatisticsQuery {
    "Count of all blocks\n\nComplexity 0"
    totalCount: Int
    "Count of blocks created by current validator set\n\nComplexity 0"
    countByCurrentValidators: Int
    "Average blocks rate per second for last 2 minutes\n\nComplexity 0"
    ratePerSecond: Float
    "Count of blocks with different versions by specified time period\n\nComplexity 0"
    countByVersion(period: CountByVersionPeriod!): JSONObject
}

enum CountByVersionPeriod {
    DAY
    HOUR
}

"\nComplexity 100"
type DepoolsStatisticsQuery {
    "Count of depools with stake > 0\n\nComplexity 0"
    activeDepoolCount: Int
    "Count of participants in all active depools\n\nComplexity 0"
    activeParticipantsCount: Int
    "Sum of rewards for active depools participants\n\nComplexity 0"
    totalRewards: String
    "Sum of stakes in all active depools\n\nComplexity 0"
    totalStaked: String
}

"A scalar that can represent any JSON Object value."
scalar JSONObject

"\nComplexity 100"
type MessagesStatisticsQuery {
    "Count of all messages\n\nComplexity 0"
    totalCount: Int
    "Average messages rate per second for last 2 minutes\n\nComplexity 0"
    ratePerSecond: Float
}

"\nComplexity 0"
type StatisticsQuery {
    "Stat API version\n\nComplexity 0"
    version: String!
    "Statistics related to blocks"
    blocks: BlocksStatisticsQuery!
    "Statistics related to messages"
    messages: MessagesStatisticsQuery!
    "Statistics related to transactions"
    transactions: TransactionsStatisticsQuery!
    "Statistics related to accounts"
    accounts: AccountsStatisticsQuery!
    "Statistics related to validators"
    validators: ValidatorsStatisticsQuery!
    "Statistics related to depools"
    depools: DepoolsStatisticsQuery!
}

"\nComplexity 100"
type TransactionsStatisticsQuery {
    "Count of ordinary transactions\n\nComplexity 0"
    totalOrdinaryCount: Int
    "Count of ordinary transactions by last 24 hours\n\nComplexity 0"
    lastDayOrdinaryCount: Int
    "Count of all transactions\n\nComplexity 0"
    totalCount: Int
    "Count of all transactions by last 24 hours\n\nComplexity 0"
    lastDayCount: Int
    "Average transactions rate per second for last 2 minutes\n\nComplexity 0"
    ratePerSecond: Float
}

"\nComplexity 100"
type ValidatorsStatisticsQuery {
    "Count of active validator set\n\nComplexity 0"
    totalCount: Int
    "Last cycle validators count delta\n\nComplexity 0"
    lastCycleCountDelta: Int
    "Staked tokens amount\n\nComplexity 0"
    totalStaked: String
    "Validators rewards for last 30 days\n\nComplexity 0"
    rewardsPer30Days: String
    "Annual percentage rate\n\nComplexity 0"
    apr: Float
}

enum Ftstandard {
    TIP_32
}

"\nComplexity 20"
type FungibleToken {
    "Token root address\n\nComplexity 0"
    address: String
    "Token standard"
    standard: Ftstandard
    "Token symbol, i.e. 'EVER'\n\nComplexity 0"
    symbol: String
    "Full name\n\nComplexity 0"
    name: String
    "Number of decimal places\n\nComplexity 0"
    decimals: Int
    "Last update time\n\nComplexity 0"
    updateTime: Int
    "Token creation time\n\nComplexity 0"
    createdAt: Int
    "Last transfer time\n\nComplexity 0"
    lastTransferTimestamp: Int
    "Root owner address\n\nComplexity 0"
    rootOwner: String
    "Total allocated and granted tokens (in tokens)\n\nComplexity 0"
    totalSupply: String
    "Token wallets"
    wallets(first: Int after: String last: Int before: String): FungibleTokenWalletConnection!
    "Token transfers"
    transfers(transferTypes: [TokenTransferTypeFilter!] first: Int after: String last: Int before: String): FungibleTokenTransferConnection!
    "Token statistics"
    statistics: FungibleTokenStatistics
}

"\nComplexity 0"
type FungibleTokenConnection {
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "A list of edges."
    edges: [FungibleTokenEdge!]!
    "A list of nodes."
    nodes: [FungibleToken!]!
}

"An edge in a connection.\n\nComplexity 0"
type FungibleTokenEdge {
    "A cursor for use in pagination\n\nComplexity 0"
    cursor: String!
    "The item at the end of the edge"
    node: FungibleToken!
}

"\nComplexity 2"
type FungibleTokenHolder {
    "\nComplexity 0"
    address: String!
    "Holder Wallets"
    wallets(tokens: [String!] first: Int after: String last: Int before: String): FungibleTokenWalletConnection!
    "Holder Transfers"
    transfers(transferTypes: [TransferTypeFilter!] first: Int after: String last: Int before: String): FungibleTokenTransferConnection!
}

"\nComplexity 0"
type FungibleTokenQuery {
    "Stat API version\n\nComplexity 0"
    version: String!
    "Returns Tokens"
    tokens(rootOwner: String symbolSubstring: String namePrefix: String first: Int after: String last: Int before: String orderBy: TokenSort): FungibleTokenConnection!
    "Returns Token"
    token(address: String!): FungibleToken
    "Returns Holder"
    holder(address: String!): FungibleTokenHolder!
    "Returns wallet"
    wallet(address: String!): FungibleTokenWallet
    "Returns holders by addresses"
    holdersByAddresses(addresses: [String!]!): [FungibleTokenHolder!]!
    "Returns transfers by message ids"
    transfersByMessageIds(messageIds: [String!]!): [FungibleTokenTransfer!]!
    "Statistics over all fungible token standarts"
    statistics: [FungibleTokenStandardStatistics!]!
}

"\nComplexity 100"
type FungibleTokenStandardStatistics {
    standard: Ftstandard
    "\nComplexity 0"
    totalTokenCount: Int
    "\nComplexity 0"
    totalWalletCount: Int
}

"\nComplexity 0"
type FungibleTokenStatistics {
    "\nComplexity 0"
    totalWalletCount: Int
}

"\nComplexity 5"
type FungibleTokenTransfer {
    "Blockchain message ID related to this transfer\n\nComplexity 0"
    messageId: String
    "Token"
    token: FungibleToken
    "Source wallet"
    fromWallet: FungibleTokenWallet
    "Destination wallet"
    toWallet: FungibleTokenWallet
    "Source holder"
    fromHolder: FungibleTokenHolder
    "Destination holder"
    toHolder: FungibleTokenHolder
    "Transfer type"
    transferType: FungibleTokenTransferType
    "Transfer message time as a UNIX timestamp in seconds\n\nComplexity 0"
    timestamp: Int
    "Transferred value of tokens.\nRepresented as a decimal string with an optional fractional part separated by `.`.\n\nComplexity 0"
    value: String
}

"\nComplexity 0"
type FungibleTokenTransferConnection {
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "A list of edges."
    edges: [FungibleTokenTransferEdge!]!
    "A list of nodes."
    nodes: [FungibleTokenTransfer!]!
}

"An edge in a connection.\n\nComplexity 0"
type FungibleTokenTransferEdge {
    "A cursor for use in pagination\n\nComplexity 0"
    cursor: String!
    "The item at the end of the edge"
    node: FungibleTokenTransfer!
}

enum FungibleTokenTransferType {
    MINT
    BURN
    TRANSFER
    REVERT_SEND
    REVERT_BURN
    REVERT_MINT
    RECEIVE
    REVERT_RECEIVE
}

"\nComplexity 20"
type FungibleTokenWallet {
    "\nComplexity 0"
    address: String
    token: FungibleToken
    holder: FungibleTokenHolder
    "Wallet transfers"
    transfers(transferTypes: [TransferTypeFilter!] first: Int after: String last: Int before: String): FungibleTokenTransferConnection!
    "\nComplexity 0"
    balance: String
    "\nComplexity 0"
    percentage: Float
}

"\nComplexity 0"
type FungibleTokenWalletConnection {
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "A list of edges."
    edges: [FungibleTokenWalletEdge!]!
    "A list of nodes."
    nodes: [FungibleTokenWallet!]!
}

"An edge in a connection.\n\nComplexity 0"
type FungibleTokenWalletEdge {
    "A cursor for use in pagination\n\nComplexity 0"
    cursor: String!
    "The item at the end of the edge"
    node: FungibleTokenWallet!
}

"\nComplexity 0"
type PageInfo {
    "\nComplexity 0"
    hasPreviousPage: Boolean!
    "\nComplexity 0"
    hasNextPage: Boolean!
    "\nComplexity 0"
    startCursor: String
    "\nComplexity 0"
    endCursor: String
}

enum TokenSort {
    NAME
    NEWEST_TO_OLDEST
    LAST_TRANSFER_FIRST
}

enum TokenTransferTypeFilter {
    MINT
    BURN
    TRANSFER
    REVERT_TRANSFER
    REVERT_BURN
    REVERT_MINT
}

enum TransferTypeFilter {
    MINT
    BURN
    SEND
    RECEIVE
    REVERT_BURN
    REVERT_MINT
    REVERT_SEND
    REVERT_RECEIVE
}

type Mutation {
    "Post external inbound message to blockchain node.\n\nComplexity 10"
    postRequests("List of message requests" requests: [Request]): [String]
    cost(dryRun: Boolean): Cost
}

" GraphQL Server info\n\nComplexity 0"
type Info {
    " Server version \n\nComplexity 0"
    version: String
    " Server unix time in ms\n\nComplexity 0"
    time: Float
    " Blocks latency in ms (server time - max of blocks.gen_utime * 1000)\n\nComplexity 0"
    blocksLatency: Float
    " Messages latency in ms (server time - max of messages.created_at * 1000)\n\nComplexity 0"
    messagesLatency: Float
    " Transactions latency in ms (server time - max of transactions.now * 1000)\n\nComplexity 0"
    transactionsLatency: Float
    " Overall latency (maximum value of blocksLatency, messagesLatency and transactionsLatency)\n\nComplexity 0"
    latency: Float
    " Last block time in ms (maximum value of blocks.gen_utime * 1000)\n\nComplexity 0"
    lastBlockTime: Float
    " Alternative endpoints of q-server\n\nComplexity 0"
    endpoints: [String]
    "**EXPERIMENTAL**\nReliable upper boundary for pagination by chain_order field. Before this boundary data inserts are almost impossible\n(work in progress to make them fully impossible when the feature goes into production).\n\nComplexity 0"
    chainOrderBoundary: String
    "Shows whether rempReceipts subscription is enabled\n\nComplexity 0"
    rempEnabled: Boolean
}

"# Account type\n\nRecall that a smart contract and an account are the same thing in the context\nof the TON Blockchain, and that these terms can be used interchangeably, at\nleast as long as only small (or “usual”) smart contracts are considered. A large\nsmart-contract may employ several accounts lying in different shardchains of\nthe same workchain for load balancing purposes.\n\nAn account is identified by its full address and is completely described by\nits state. In other words, there is nothing else in an account apart from its\naddress and state.\n\nComplexity 5"
type BlockchainAccount implements Node {
    "BlockchainAccount.id is \"account\/\"-prefixed Account.id.\nFor id without prefix see \"address\".\n\nComplexity 0"
    id: ID!
    "\nComplexity 0"
    address: String
    "Returns the current status of the account.\n\n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist\n\nComplexity 0"
    acc_type: Int
    acc_type_name: AccountStatusEnum
    "\nComplexity 0"
    balance(format: BigIntFormat): String
    balance_other: [OtherCurrency]
    "Contains sum of all the bits used by the cells of the account. Used in storage fee calculation\n\nComplexity 0"
    bits(format: BigIntFormat): String
    "Bag of cells with the account struct encoded as base64.\n\nComplexity 5"
    boc: String
    "Contains number of the cells of the account. Used in storage fee calculation\n\nComplexity 0"
    cells(format: BigIntFormat): String
    "If present, contains smart-contract code encoded with in base64.\n\nComplexity 2"
    code: String
    "`code` field root hash.\n\nComplexity 0"
    code_hash: String
    "If present, contains smart-contract data encoded with in base64.\n\nComplexity 3"
    data: String
    "`data` field root hash.\n\nComplexity 0"
    data_hash: String
    "If present, accumulates the storage payments that could not be exacted from\nthe balance of the account, represented by a strictly positive amount of nano\ntokens; it can be present only for uninitialized or frozen accounts that have\na balance of zero Grams (but may have non-zero balances in non gram\ncryptocurrencies). When due_payment becomes larger than the value of a\nconfigurable parameter of the blockchain, the ac- count is destroyed\naltogether, and its balance, if any, is transferred to the zero account.\n\nComplexity 0"
    due_payment(format: BigIntFormat): String
    "account 's initial code hash (when it was deployed)\n\nComplexity 0"
    init_code_hash: String
    "Contains either the unixtime of the most recent storage payment\ncollected (usually this is the unixtime of the most recent transaction),\nor the unixtime when the account was created (again, by a transaction).\n\nComplexity 0"
    last_paid: Float
    "\nComplexity 0"
    last_trans_lt(format: BigIntFormat): String
    "If present, contains library code used in smart-contract.\n\nComplexity 0"
    library: String
    "`library` field root hash.\n\nComplexity 0"
    library_hash: String
    "\nComplexity 0"
    prev_code_hash: String
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64.\n\nComplexity 0"
    proof: String
    "Contains the number of public cells of the account. Used in storage fee calculation.\n\nComplexity 0"
    public_cells(format: BigIntFormat): String
    "Is present and non-zero only in instances of large smart contracts.\n\nComplexity 0"
    split_depth: Int
    "Contains the representation hash of an instance of `StateInit` when an account is frozen.\n\nComplexity 0"
    state_hash: String
    "May be present only in the masterchain—and within the masterchain, only in some\nfundamental smart contracts required for the whole system to function.\n\nComplexity 0"
    tick: Boolean
    "May be present only in the masterchain—and within the masterchain, only in some\nfundamental smart contracts required for the whole system to function.\n\nComplexity 0"
    tock: Boolean
    "Workchain id of the account address (id field).\n\nComplexity 0"
    workchain_id: Int
    tokenHolder: FungibleTokenHolder
}

"Block\n\nComplexity 10"
type BlockchainBlock implements Node {
    "BlockchainBlock.id is \"block\/\"-prefixed Block.id.\nFor id without prefix see \"hash\".\n\nComplexity 0"
    id: ID!
    "\nComplexity 0"
    hash: String
    account_blocks: [BlockAccountBlocks]
    "\nComplexity 0"
    after_merge: Boolean
    "\nComplexity 0"
    after_split: Boolean
    "\nComplexity 0"
    before_split: Boolean
    "Serialized bag of cells of this block encoded with base64\n\nComplexity 10"
    boc: String
    "Collection-unique field for pagination and sorting. This field is designed to retain logical order.\n\nComplexity 0"
    chain_order: String
    "Public key of the collator who produced this block.\n\nComplexity 0"
    created_by: String
    "Logical creation time automatically set by the block formation end.\n\nComplexity 0"
    end_lt(format: BigIntFormat): String
    "Block file hash\n\nComplexity 0"
    file_hash: String
    "\nComplexity 0"
    flags: Int
    "\nComplexity 0"
    gen_catchain_seqno: Float
    "\nComplexity 0"
    gen_software_capabilities(format: BigIntFormat): String
    "\nComplexity 0"
    gen_software_version: Float
    "uint 32 generation time stamp\n\nComplexity 0"
    gen_utime: Float
    "\nComplexity 0"
    gen_utime_string: String
    "\nComplexity 0"
    gen_validator_list_hash_short: Float
    "uint32 global block ID\n\nComplexity 0"
    global_id: Int
    in_msg_descr: [InMsg]
    "true if this block is a key block\n\nComplexity 0"
    key_block: Boolean
    master: BlockMaster
    master_ref: ExtBlkRef
    "Returns last known master block at the time of shard generation.\n\nComplexity 0"
    min_ref_mc_seqno: Float
    out_msg_descr: [OutMsg]
    "External block reference for previous block in case of shard merge."
    prev_alt_ref: ExtBlkRef
    "Returns a number of a previous key block.\n\nComplexity 0"
    prev_key_block_seqno: Float
    "External block reference for previous block."
    prev_ref: ExtBlkRef
    prev_vert_alt_ref: ExtBlkRef
    "External block reference for previous block in case of vertical blocks."
    prev_vert_ref: ExtBlkRef
    "\nComplexity 0"
    rand_seed: String
    "\nComplexity 0"
    seq_no: Float
    "\nComplexity 0"
    shard: String
    "Logical creation time automatically set by the block formation start.\nLogical time is a component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see the TON blockchain specification\n\nComplexity 0"
    start_lt(format: BigIntFormat): String
    state_update: BlockStateUpdate
    "Returns block processing status\n- 0 – unknown\n- 1 – proposed\n- 2 – finalized\n- 3 – refused\n\nComplexity 0"
    status: Int
    status_name: BlockProcessingStatusEnum
    "\nComplexity 0"
    tr_count: Int
    value_flow: BlockValueFlow
    "uin32 block version identifier\n\nComplexity 0"
    version: Float
    "\nComplexity 0"
    vert_seq_no: Float
    "\nComplexity 0"
    want_merge: Boolean
    "\nComplexity 0"
    want_split: Boolean
    "uint32 workchain identifier\n\nComplexity 0"
    workchain_id: Int
}

"\nComplexity 0"
type BlockchainMasterSeqNoRange {
    "INCLUSIVE seq_no range border.\nMasterchain block seq_no that corresponds to the specified time_start left border of\ntime interval.\nCan be used to define pagination range in functions, providing cursor-based pagination.\n\nIf no corresponding masterchain block was found, null is returned. It may happen when the\ntime_start timestamp refers to the historic data which is not available.\n\nComplexity 0"
    start: Int
    "EXCLUSIVE seq_no range border.\nMasterchain block seq_no that corresponds to the specified time_end right border of\ntime interval.\nCan be used to define pagination range in functions, providing cursor-based pagination.\n\nIf no seq_no was found, returns `null`.\nThis may happen if there is no corresponding masterchain block yet for\nthe specified `time_end` timestamp when `time_end` is close to `now`. We recommend\nommiting the right border seq_no for recent data pagination.\n\nComplexity 0"
    end: Int
}

input BlockchainMasterSeqNoFilter {
    "Minimum inclusive seq_no of corresponding master blocks"
    start: Int
    "Maximum exclusive seq_no of corresponding master blocks"
    end: Int
}

"\nComplexity 0"
type BlockchainBlocksConnection {
    edges: [BlockchainBlocksEdge!]!
    pageInfo: PageInfo!
}

"\nComplexity 0"
type BlockchainBlocksEdge {
    node: BlockchainBlock!
    "\nComplexity 0"
    cursor: String!
}

"\nComplexity 0"
type BlockchainTransactionsConnection {
    edges: [BlockchainTransactionEdge!]!
    pageInfo: PageInfo!
}

"\nComplexity 0"
type BlockchainTransactionEdge {
    node: BlockchainTransaction!
    "\nComplexity 0"
    cursor: String!
}

enum BlockchainMessageTypeFilterEnum {
    "External inbound"
    ExtIn
    "External outbound"
    ExtOut
    "Internal inbound"
    IntIn
    "Internal outbound"
    IntOut
}

"\nComplexity 0"
type BlockchainMessagesConnection {
    edges: [BlockchainMessageEdge!]!
    pageInfo: PageInfo!
}

"\nComplexity 0"
type BlockchainMessageEdge {
    node: BlockchainMessage!
    "\nComplexity 0"
    cursor: String!
}

"\nComplexity 0"
type BlockchainQuery {
    "Account-related information"
    account("Account address is required (64 hex symbols)" address: String!): BlockchainAccountQuery
    block(hash: String!): BlockchainBlock
    block_by_seq_no(workchain: Int! thread: String! seq_no: Float!): BlockchainBlock
    transaction(hash: String!): BlockchainTransaction
    message(hash: String!): BlockchainMessage
    "Returns masterchain seq_no range for the specified time range\nto be used further in pagination functions.\nIf `time_start` and\/or `time_end` is null, then the corresponding seq_no range border\nis also null."
    master_seq_no_range("Start of the time range, inclusive" time_start: Int "End of the time range, exclusive" time_end: Int): BlockchainMasterSeqNoRange
    "This node could be used for a cursor-based pagination of key blocks."
    key_blocks("By default there is special latency added for the fetched recent data (several seconds) to\nensure impossibility of inserts before the latest fetched cursor (data consistency, for reliable pagination).\nIt is possible to disable this guarantee and to reduce the latency of realtime data by setting this flag to true." allow_latest_inconsistent_data: Boolean "Filter by master blocks seq_no." master_seq_no_range: BlockchainMasterSeqNoFilter "This field is mutually exclusive with 'last'" first: Int after: String "This field is mutually exclusive with 'first'" last: Int before: String): BlockchainBlocksConnection
    "This node could be used for a cursor-based pagination of blocks."
    blocks("By default there is special latency added for the fetched recent data (several seconds) to\nensure impossibility of inserts before the latest fetched cursor (data consistency, for reliable pagination).\nIt is possible to disable this guarantee and to reduce the latency of realtime data by setting this flag to true." allow_latest_inconsistent_data: Boolean "The blocks could be filtered by seq_no of corresponding masterchain blocks.\nSee also: blockсhain { master_seq_no_range }" master_seq_no_range: BlockchainMasterSeqNoFilter "Optional filter by workchain" workchain: Int "Optional filter by thread (former 'shard'). Workchain filter is required if this filter is used" thread: String "Optional filter by minimum transactions in a block (unoptimized, query could be dropped by timeout)" min_tr_count: Int "Optional filter by maximum transactions in a block (unoptimized, query could be dropped by timeout)" max_tr_count: Int "This field is mutually exclusive with 'last'" first: Int after: String "This field is mutually exclusive with 'first'" last: Int before: String): BlockchainBlocksConnection
    "This node could be used for a cursor-based pagination of transactions."
    transactions("By default there is special latency added for the fetched recent data (several seconds) to\nensure impossibility of inserts before the latest fetched cursor (data consistency, for reliable pagination).\nIt is possible to disable this guarantee and to reduce the latency of realtime data by setting this flag to true." allow_latest_inconsistent_data: Boolean "The transactions could be filtered by seq_no of corresponding masterchain blocks.\nSee also: blockchain { master_seq_no_range }" master_seq_no_range: BlockchainMasterSeqNoFilter "Optional filter by workchain" workchain: Int "Optional filter by min balance_delta (unoptimized, query could be dropped by timeout)" min_balance_delta: String "Optional filter by max balance_delta (unoptimized, query could be dropped by timeout)" max_balance_delta: String "This field is mutually exclusive with 'last'" first: Int after: String "This field is mutually exclusive with 'first'" last: Int before: String): BlockchainTransactionsConnection
}

"\nComplexity 0"
type BlockchainAccountQuery {
    "Account information (e.g. boc)."
    info: BlockchainAccount
    "This node could be used for a cursor-based pagination of account transactions."
    transactions("By default there is special latency added for the fetched recent data (several seconds) to\nensure impossibility of inserts before the latest fetched cursor (data consistency, for reliable pagination).\nIt is possible to disable this guarantee and to reduce the latency of realtime data by setting this flag to true." allow_latest_inconsistent_data: Boolean "The transactions could be filtered by seq_no of corresponding masterchain blocks.\nSee also: \"master_seq_no_range\"" master_seq_no_range: BlockchainMasterSeqNoFilter aborted: Boolean "Optional filter by min balance_delta (unoptimized, query could be dropped by timeout)" min_balance_delta: String "Optional filter by max balance_delta (unoptimized, query could be dropped by timeout)" max_balance_delta: String "This field is mutually exclusive with 'last'" first: Int after: String "This field is mutually exclusive with 'first'" last: Int before: String): BlockchainTransactionsConnection
    "This node could be used for a cursor-based pagination of account messages."
    messages("By default there is special latency added for the fetched recent data (several seconds) to\nensure impossibility of inserts before the latest fetched cursor (data consistency, for reliable pagination).\nIt is possible to disable this guarantee and to reduce the latency of realtime data by setting this flag to true." allow_latest_inconsistent_data: Boolean "The messages could be filtered by seq_no of corresponding masterchain blocks.\nSee also: \"master_seq_no_range\"" master_seq_no_range: BlockchainMasterSeqNoFilter "Filter messages by counterparties (max - 5 counterparties)." counterparties: [String!] "Filter messages by type (multiple are allowed, all messages if not specified)." msg_type: [BlockchainMessageTypeFilterEnum!] "Optional filter by min value (unoptimized, query could be dropped by timeout)" min_value: String "This field is mutually exclusive with 'last'" first: Int after: String "This field is mutually exclusive with 'first'" last: Int before: String): BlockchainMessagesConnection
}

interface Node {
    id: ID!
}

"# Message type\n\nMessage layout queries.  A message consists of its header followed by its\nbody or payload. The body is essentially arbitrary, to be interpreted by the\ndestination smart contract. It can be queried with the following fields:\n\nComplexity 3"
type BlockchainMessage implements Node {
    "BlockchainMessage.id is \"message\/\"-prefixed Message.id.\nFor id without prefix see \"hash\".\n\nComplexity 0"
    id: ID!
    "\nComplexity 0"
    hash: String
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64.\n\nComplexity 0"
    block_id: String
    "A bag of cells with the message structure encoded as base64.\n\nComplexity 3"
    boc: String
    "Bag of cells with the message body encoded as base64.\n\nComplexity 0"
    body: String
    "`body` field root hash.\n\nComplexity 0"
    body_hash: String
    "Bounce flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender.\n\nComplexity 0"
    bounce: Boolean
    "Bounced flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender.\n\nComplexity 0"
    bounced: Boolean
    "Collection-unique field for pagination and sorting. This field is designed to retain logical output order (for logical input order use transaction.in_message).\n\nComplexity 0"
    chain_order: String
    "Represents contract code in deploy messages.\n\nComplexity 1"
    code: String
    "`code` field root hash.\n\nComplexity 0"
    code_hash: String
    "Creation unixtime automatically set by the generating transaction. The creation unixtime equals the creation unixtime of the block containing the generating transaction.\n\nComplexity 0"
    created_at: Float
    "\nComplexity 0"
    created_at_string: String
    "Logical creation time automatically set by the generating transaction.\n\nComplexity 0"
    created_lt(format: BigIntFormat): String
    "Represents initial data for a contract in deploy messages\n\nComplexity 2"
    data: String
    "`data` field root hash.\n\nComplexity 0"
    data_hash: String
    "Returns destination address string\n\nComplexity 0"
    dst: String
    "The destination account"
    dst_account: BlockchainAccount
    "The transaction in which this message is in_msg"
    dst_transaction: BlockchainTransaction
    "Workchain id of the destination address (dst field)\n\nComplexity 0"
    dst_workchain_id: Int
    "Original total forwarding fee paid for using the HR mechanism; it is automatically computed from some configuration parameters and the size of the message at the time the message is generated.\n\nComplexity 0"
    fwd_fee(format: BigIntFormat): String
    "IHR is disabled for the message.\n\nComplexity 0"
    ihr_disabled: Boolean
    "This value is subtracted from the value attached to the message and awarded to the validators of the destination shardchain if they include the message by the IHR mechanism.\n\nComplexity 0"
    ihr_fee(format: BigIntFormat): String
    "\nComplexity 0"
    import_fee(format: BigIntFormat): String
    "Represents contract library in deploy messages\n\nComplexity 0"
    library: String
    "`library` field root hash.\n\nComplexity 0"
    library_hash: String
    "Returns the type of message.\n- 0 – internal\n- 1 – extIn\n- 2 – extOut\n\nComplexity 0"
    msg_type: Int
    msg_type_name: MessageTypeEnum
    "Merkle proof that message is a part of a block it cut from. It is a bag of cells with Merkle proof struct encoded as base64.\n\nComplexity 0"
    proof: String
    "This is only used for special contracts in masterchain to deploy messages.\n\nComplexity 0"
    split_depth: Int
    "Returns source address string\n\nComplexity 0"
    src: String
    "The source account"
    src_account: BlockchainAccount
    "The transaction in which this message is included to out_msgs"
    src_transaction: BlockchainTransaction
    "Workchain id of the source address (src field)\n\nComplexity 0"
    src_workchain_id: Int
    "Returns internal processing status according to the numbers shown.\n- 0 – unknown\n- 1 – queued\n- 2 – processing\n- 3 – preliminary\n- 4 – proposed\n- 5 – finalized\n- 6 – refused\n- 7 – transiting\n\nComplexity 0"
    status: Int
    status_name: MessageProcessingStatusEnum
    "This is only used for special contracts in masterchain to deploy messages.\n\nComplexity 0"
    tick: Boolean
    "This is only used for special contracts in masterchain to deploy messages\n\nComplexity 0"
    tock: Boolean
    "May or may not be present\n\nComplexity 0"
    value(format: BigIntFormat): String
    "May or may not be present."
    value_other: [OtherCurrency]
    tokenTransfer: FungibleTokenTransfer
}

"Transaction\n\nComplexity 5"
type BlockchainTransaction implements Node {
    "BlockchainTransaction.id is \"transaction\/\"-prefixed Transaction.id.\nFor id without prefix see \"hash\".\n\nComplexity 0"
    id: ID!
    "\nComplexity 0"
    hash: String
    "\nComplexity 0"
    aborted: Boolean
    account: BlockchainAccount
    "\nComplexity 0"
    account_addr: String
    action: TransactionAction
    "Account balance change after transaction\n\nComplexity 0"
    balance_delta(format: BigIntFormat): String
    "Account balance change after transaction"
    balance_delta_other: [OtherCurrency]
    "\nComplexity 0"
    block_id: String
    "\nComplexity 4"
    boc: String
    bounce: TransactionBounce
    "Collection-unique field for pagination and sorting. This field is designed to retain logical order.\n\nComplexity 0"
    chain_order: String
    compute: TransactionCompute
    credit: TransactionCredit
    "\nComplexity 0"
    credit_first: Boolean
    "\nComplexity 0"
    destroyed: Boolean
    "The end state of an account after a transaction, 1 is returned to indicate a finalized transaction at an active account\n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist\n\nComplexity 0"
    end_status: Int
    end_status_name: AccountStatusEnum
    "Fee for inbound external message import.\n\nComplexity 0"
    ext_in_msg_fee(format: BigIntFormat): String
    in_message: BlockchainMessage
    "\nComplexity 0"
    in_msg: String
    "\nComplexity 0"
    installed: Boolean
    "Logical time. A component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see [the TON blockchain specification](https:\/\/test.ton.org\/tblkch.pdf).\n\nComplexity 0"
    lt(format: BigIntFormat): String
    "Merkle update field\n\nComplexity 0"
    new_hash: String
    "\nComplexity 0"
    now: Float
    "\nComplexity 0"
    now_string: String
    "Merkle update field\n\nComplexity 0"
    old_hash: String
    "The initial state of account. Note that in this case the query may return 0, if the account was not active before the transaction and 1 if it was already active\n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist\n\nComplexity 0"
    orig_status: Int
    orig_status_name: AccountStatusEnum
    out_messages: [BlockchainMessage]
    "\nComplexity 0"
    out_msgs: [String]
    "The number of generated outbound messages (one of the common transaction parameters defined by the specification)\n\nComplexity 0"
    outmsg_cnt: Int
    "\nComplexity 0"
    prepare_transaction: String
    "\nComplexity 0"
    prev_trans_hash: String
    "\nComplexity 0"
    prev_trans_lt(format: BigIntFormat): String
    "\nComplexity 0"
    proof: String
    split_info: TransactionSplitInfo
    "Transaction processing status\n- 0 – unknown\n- 1 – preliminary\n- 2 – proposed\n- 3 – finalized\n- 4 – refused\n\nComplexity 0"
    status: Int
    status_name: TransactionProcessingStatusEnum
    storage: TransactionStorage
    "Total amount of fees collected by the validators.\nBecause fwd_fee is collected by the validators of the receiving shard,\ntotal_fees value does not include Sum(out_msg.fwd_fee[]), but includes in_msg.fwd_fee.\nThe formula is:\ntotal_fees = in_msg.value - balance_delta - Sum(out_msg.value[]) - Sum(out_msg.fwd_fee[])\n\nComplexity 0"
    total_fees(format: BigIntFormat): String
    "Same as above, but reserved for non gram coins that may appear in the blockchain"
    total_fees_other: [OtherCurrency]
    "Transaction type according to the original blockchain specification, clause 4.2.4.\n- 0 – ordinary\n- 1 – storage\n- 2 – tick\n- 3 – tock\n- 4 – splitPrepare\n- 5 – splitInstall\n- 6 – mergePrepare\n- 7 – mergeInstall\n\nComplexity 0"
    tr_type: Int
    tr_type_name: TransactionTypeEnum
    "\nComplexity 0"
    tt: String
    "Workchain id of the account address (account_addr field)\n\nComplexity 0"
    workchain_id: Int
    tokenTransfer: FungibleTokenTransfer
}

"Due to GraphQL limitations big numbers are returned as a string.\nYou can specify format used to string representation for big integers."
enum BigIntFormat {
    " Hexadecimal representation started with 0x (default) "
    HEX
    " Decimal representation "
    DEC
}

input StringFilter {
    eq: String
    ne: String
    gt: String
    lt: String
    ge: String
    le: String
    in: [String]
    notIn: [String]
}

input BooleanFilter {
    eq: Boolean
    ne: Boolean
    gt: Boolean
    lt: Boolean
    ge: Boolean
    le: Boolean
    in: [Boolean]
    notIn: [Boolean]
}

input IntFilter {
    eq: Int
    ne: Int
    gt: Int
    lt: Int
    ge: Int
    le: Int
    in: [Int]
    notIn: [Int]
}

input FloatFilter {
    eq: Float
    ne: Float
    gt: Float
    lt: Float
    ge: Float
    le: Float
    in: [Float]
    notIn: [Float]
}

enum InMsgTypeEnum {
    External
    Ihr
    Immediately
    Final
    Transit
    DiscardedFinal
    DiscardedTransit
}

enum OutMsgTypeEnum {
    External
    Immediately
    OutMsgNew
    Transit
    DequeueImmediately
    Dequeue
    TransitRequired
    DequeueShort
    None
}

enum AccountStatusEnum {
    Uninit
    Active
    Frozen
    NonExist
}

enum TransactionTypeEnum {
    Ordinary
    Storage
    Tick
    Tock
    SplitPrepare
    SplitInstall
    MergePrepare
    MergeInstall
}

enum TransactionProcessingStatusEnum {
    Unknown
    Preliminary
    Proposed
    Finalized
    Refused
}

enum AccountStatusChangeEnum {
    Unchanged
    Frozen
    Deleted
}

enum ComputeTypeEnum {
    Skipped
    Vm
}

enum SkipReasonEnum {
    NoState
    BadState
    NoGas
}

enum BounceTypeEnum {
    NegFunds
    NoFunds
    Ok
}

enum MessageTypeEnum {
    Internal
    ExtIn
    ExtOut
}

enum MessageProcessingStatusEnum {
    Unknown
    Queued
    Processing
    Preliminary
    Proposed
    Finalized
    Refused
    Transiting
}

enum BlockProcessingStatusEnum {
    Unknown
    Proposed
    Finalized
    Refused
}

enum SplitTypeEnum {
    None
    Split
    Merge
}

enum CapabilitiesFlag {
    CapNone
    CapIhrEnabled
    CapCreateStatsEnabled
    CapBounceMsgBody
    CapReportVersion
    CapSplitMergeTransactions
    CapShortDequeue
    CapMbppEnabled
    CapFastStorageStat
    CapInitCodeHash
    CapOffHypercube
    CapMyCode
    CapSetLibCode
    CapFixTupleIndexBug
    CapRemp
    CapDElections
    CapFullBodyInBounced
    CapStorageFeeToTvm
    CapCopyleft
    CapIndexAccounts
    CapDiff
    CapsTvmBugfixes2022
    CapWorkchains
    CapStcontNewFormat
    CapFastStorageStatBugfix
    CapResolveMerkleCell
    CapSignatureWithId
}

"\nComplexity 0"
type OtherCurrency {
    "\nComplexity 0"
    currency: Float
    "\nComplexity 0"
    value(format: BigIntFormat): String
}

"\nComplexity 0"
type ExtBlkRef {
    "\nComplexity 0"
    end_lt(format: BigIntFormat): String
    "\nComplexity 0"
    file_hash: String
    "\nComplexity 0"
    root_hash: String
    "\nComplexity 0"
    seq_no: Float
}

"\nComplexity 0"
type MsgEnvelope {
    "\nComplexity 0"
    cur_addr: String
    "\nComplexity 0"
    fwd_fee_remaining(format: BigIntFormat): String
    "\nComplexity 0"
    msg_id: String
    "\nComplexity 0"
    next_addr: String
}

"\nComplexity 10"
type InMsg {
    "\nComplexity 0"
    fwd_fee(format: BigIntFormat): String
    "\nComplexity 0"
    ihr_fee(format: BigIntFormat): String
    in_msg: MsgEnvelope
    "\nComplexity 0"
    msg_id: String
    "- 0 – external\n- 1 – ihr\n- 2 – immediately\n- 3 – final\n- 4 – transit\n- 5 – discardedFinal\n- 6 – discardedTransit\n\nComplexity 0"
    msg_type: Int
    msg_type_name: InMsgTypeEnum
    out_msg: MsgEnvelope
    "\nComplexity 0"
    proof_created: String
    "\nComplexity 0"
    proof_delivered: String
    "\nComplexity 0"
    transaction_id: String
    "\nComplexity 0"
    transit_fee(format: BigIntFormat): String
}

"\nComplexity 10"
type OutMsg {
    "\nComplexity 0"
    import_block_lt(format: BigIntFormat): String
    imported: InMsg
    "\nComplexity 0"
    msg_env_hash: String
    "\nComplexity 0"
    msg_id: String
    "- 0 – external\n- 1 – immediately\n- 2 – outMsgNew\n- 3 – transit\n- 4 – dequeueImmediately\n- 5 – dequeue\n- 6 – transitRequired\n- 7 – dequeueShort\n- -1 – none\n\nComplexity 0"
    msg_type: Int
    msg_type_name: OutMsgTypeEnum
    "\nComplexity 0"
    next_addr_pfx(format: BigIntFormat): String
    "\nComplexity 0"
    next_workchain: Int
    out_msg: MsgEnvelope
    reimport: InMsg
    "\nComplexity 0"
    transaction_id: String
}

"\nComplexity 0"
type GasLimitsPrices {
    "\nComplexity 0"
    block_gas_limit(format: BigIntFormat): String
    "\nComplexity 0"
    delete_due_limit(format: BigIntFormat): String
    "\nComplexity 0"
    flat_gas_limit(format: BigIntFormat): String
    "\nComplexity 0"
    flat_gas_price(format: BigIntFormat): String
    "\nComplexity 0"
    freeze_due_limit(format: BigIntFormat): String
    "\nComplexity 0"
    gas_credit(format: BigIntFormat): String
    "\nComplexity 0"
    gas_limit(format: BigIntFormat): String
    "\nComplexity 0"
    gas_price(format: BigIntFormat): String
    "\nComplexity 0"
    special_gas_limit(format: BigIntFormat): String
}

"\nComplexity 0"
type BlockLimitsBytes {
    "\nComplexity 0"
    hard_limit: Float
    "\nComplexity 0"
    soft_limit: Float
    "\nComplexity 0"
    underload: Float
}

"\nComplexity 0"
type BlockLimitsGas {
    "\nComplexity 0"
    hard_limit: Float
    "\nComplexity 0"
    soft_limit: Float
    "\nComplexity 0"
    underload: Float
}

"\nComplexity 0"
type BlockLimitsLtDelta {
    "\nComplexity 0"
    hard_limit: Float
    "\nComplexity 0"
    soft_limit: Float
    "\nComplexity 0"
    underload: Float
}

"\nComplexity 0"
type BlockLimits {
    bytes: BlockLimitsBytes
    gas: BlockLimitsGas
    lt_delta: BlockLimitsLtDelta
}

"\nComplexity 0"
type MsgForwardPrices {
    "\nComplexity 0"
    bit_price(format: BigIntFormat): String
    "\nComplexity 0"
    cell_price(format: BigIntFormat): String
    "\nComplexity 0"
    first_frac: Int
    "\nComplexity 0"
    ihr_price_factor: Float
    "\nComplexity 0"
    lump_price(format: BigIntFormat): String
    "\nComplexity 0"
    next_frac: Int
}

"\nComplexity 0"
type ValidatorSetList {
    "\nComplexity 0"
    adnl_addr: String
    "\nComplexity 0"
    public_key: String
    "\nComplexity 0"
    weight(format: BigIntFormat): String
}

"\nComplexity 0"
type ValidatorSet {
    list: [ValidatorSetList]
    "\nComplexity 0"
    main: Int
    "\nComplexity 0"
    total: Int
    "\nComplexity 0"
    total_weight(format: BigIntFormat): String
    "\nComplexity 0"
    utime_since: Float
    "\nComplexity 0"
    utime_since_string: String
    "\nComplexity 0"
    utime_until: Float
    "\nComplexity 0"
    utime_until_string: String
}

"\nComplexity 0"
type ConfigProposalSetup {
    "\nComplexity 0"
    bit_price: Float
    "\nComplexity 0"
    cell_price: Float
    "\nComplexity 0"
    max_losses: Int
    "\nComplexity 0"
    max_store_sec: Float
    "\nComplexity 0"
    max_tot_rounds: Int
    "\nComplexity 0"
    min_store_sec: Float
    "\nComplexity 0"
    min_tot_rounds: Int
    "\nComplexity 0"
    min_wins: Int
}

"Configuration parameter 6\n\nComplexity 0"
type ConfigP6 {
    "\nComplexity 0"
    mint_add_price: String
    "\nComplexity 0"
    mint_new_price: String
}

"\nComplexity 0"
type ConfigP7 {
    "\nComplexity 0"
    currency: Float
    "\nComplexity 0"
    value: String
}

"Global version\n\nComplexity 0"
type ConfigP8 {
    "- 0x0 – CapNone\n- 0x1 – CapIhrEnabled\n- 0x2 – CapCreateStatsEnabled\n- 0x4 – CapBounceMsgBody\n- 0x8 – CapReportVersion\n- 0x10 – CapSplitMergeTransactions\n- 0x20 – CapShortDequeue\n- 0x40 – CapMbppEnabled\n- 0x80 – CapFastStorageStat\n- 0x100 – CapInitCodeHash\n- 0x200 – CapOffHypercube\n- 0x400 – CapMyCode\n- 0x800 – CapSetLibCode\n- 0x1000 – CapFixTupleIndexBug\n- 0x2000 – CapRemp\n- 0x4000 – CapDElections\n- 0x10000 – CapFullBodyInBounced\n- 0x20000 – CapStorageFeeToTvm\n- 0x40000 – CapCopyleft\n- 0x80000 – CapIndexAccounts\n- 0x100000 – CapDiff\n- 0x200000 – CapsTvmBugfixes2022\n- 0x400000 – CapWorkchains\n- 0x800000 – CapStcontNewFormat\n- 0x1000000 – CapFastStorageStatBugfix\n- 0x2000000 – CapResolveMerkleCell\n- 0x4000000 – CapSignatureWithId\n\nComplexity 0"
    capabilities(format: BigIntFormat): String
    capabilities_flags: [CapabilitiesFlag]
    "\nComplexity 0"
    version: Float
}

"Config voting setup\n\nComplexity 0"
type ConfigP11 {
    critical_params: ConfigProposalSetup
    normal_params: ConfigProposalSetup
}

"\nComplexity 0"
type ConfigP12 {
    "\nComplexity 0"
    accept_msgs: Boolean
    "\nComplexity 0"
    active: Boolean
    "\nComplexity 0"
    actual_min_split: Int
    "\nComplexity 0"
    addr_len_step: Int
    "\nComplexity 0"
    basic: Boolean
    "\nComplexity 0"
    enabled_since: Float
    "\nComplexity 0"
    flags: Int
    "\nComplexity 0"
    max_addr_len: Int
    "\nComplexity 0"
    max_split: Int
    "\nComplexity 0"
    min_addr_len: Int
    "\nComplexity 0"
    min_split: Int
    "\nComplexity 0"
    version: Float
    "\nComplexity 0"
    vm_mode: String
    "\nComplexity 0"
    vm_version: Int
    "\nComplexity 0"
    workchain_id: Int
    "\nComplexity 0"
    workchain_type_id: Float
    "\nComplexity 0"
    zerostate_file_hash: String
    "\nComplexity 0"
    zerostate_root_hash: String
}

"Block create fees\n\nComplexity 0"
type ConfigP14 {
    "\nComplexity 0"
    basechain_block_fee(format: BigIntFormat): String
    "\nComplexity 0"
    masterchain_block_fee(format: BigIntFormat): String
}

"Election parameters\n\nComplexity 0"
type ConfigP15 {
    "\nComplexity 0"
    elections_end_before: Float
    "\nComplexity 0"
    elections_start_before: Float
    "\nComplexity 0"
    stake_held_for: Float
    "\nComplexity 0"
    validators_elected_for: Float
}

"Validators count\n\nComplexity 0"
type ConfigP16 {
    "\nComplexity 0"
    max_main_validators: Int
    "\nComplexity 0"
    max_validators: Int
    "\nComplexity 0"
    min_validators: Int
}

"Validator stake parameters\n\nComplexity 0"
type ConfigP17 {
    "\nComplexity 0"
    max_stake(format: BigIntFormat): String
    "\nComplexity 0"
    max_stake_factor: Float
    "\nComplexity 0"
    min_stake(format: BigIntFormat): String
    "\nComplexity 0"
    min_total_stake(format: BigIntFormat): String
}

"\nComplexity 0"
type ConfigP18 {
    "\nComplexity 0"
    bit_price_ps(format: BigIntFormat): String
    "\nComplexity 0"
    cell_price_ps(format: BigIntFormat): String
    "\nComplexity 0"
    mc_bit_price_ps(format: BigIntFormat): String
    "\nComplexity 0"
    mc_cell_price_ps(format: BigIntFormat): String
    "\nComplexity 0"
    utime_since: Float
    "\nComplexity 0"
    utime_since_string: String
}

"Catchain config\n\nComplexity 0"
type ConfigP28 {
    "\nComplexity 0"
    mc_catchain_lifetime: Float
    "\nComplexity 0"
    shard_catchain_lifetime: Float
    "\nComplexity 0"
    shard_validators_lifetime: Float
    "\nComplexity 0"
    shard_validators_num: Float
    "\nComplexity 0"
    shuffle_mc_validators: Boolean
}

"Consensus config\n\nComplexity 0"
type ConfigP29 {
    "\nComplexity 0"
    attempt_duration: Float
    "\nComplexity 0"
    catchain_max_deps: Float
    "\nComplexity 0"
    consensus_timeout_ms: Float
    "\nComplexity 0"
    fast_attempts: Float
    "\nComplexity 0"
    max_block_bytes: Float
    "\nComplexity 0"
    max_collated_bytes: Float
    "\nComplexity 0"
    new_catchain_ids: Boolean
    "\nComplexity 0"
    next_candidate_delay_ms: Float
    "\nComplexity 0"
    round_candidates: Float
}

"\nComplexity 0"
type ConfigP30 {
    "\nComplexity 0"
    delections_step: Float
    "\nComplexity 0"
    staker_init_code_hash: String
    "\nComplexity 0"
    validator_init_code_hash: String
}

"\nComplexity 0"
type ConfigP39 {
    "\nComplexity 0"
    adnl_addr: String
    "\nComplexity 0"
    map_key: String
    "\nComplexity 0"
    seqno: Float
    "\nComplexity 0"
    signature_r: String
    "\nComplexity 0"
    signature_s: String
    "\nComplexity 0"
    temp_public_key: String
    "\nComplexity 0"
    valid_until: Float
}

"\nComplexity 0"
type ConfigP40 {
    "\nComplexity 0"
    collations_score_weight: Float
    "\nComplexity 0"
    min_samples_count: Float
    "\nComplexity 0"
    min_slashing_protection_score: Float
    "\nComplexity 0"
    resend_mc_blocks_count: Float
    "\nComplexity 0"
    signing_score_weight: Float
    "\nComplexity 0"
    slashing_period_mc_blocks_count: Float
    "\nComplexity 0"
    z_param_denominator: Float
    "\nComplexity 0"
    z_param_numerator: Float
}

"\nComplexity 0"
type ConfigP42Payouts {
    "\nComplexity 0"
    license_type: Int
    "\nComplexity 0"
    payout_percent: Int
}

"\nComplexity 0"
type ConfigP42 {
    payouts: [ConfigP42Payouts]
    "\nComplexity 0"
    threshold(format: BigIntFormat): String
}

"\nComplexity 0"
type Config {
    "Address of config smart contract in the masterchain\n\nComplexity 0"
    p0: String
    "Address of elector smart contract in the masterchain\n\nComplexity 0"
    p1: String
    "Critical params\n\nComplexity 0"
    p10: [Float]
    "Config voting setup"
    p11: ConfigP11
    "Array of all workchains descriptions"
    p12: [ConfigP12]
    "Block create fees"
    p14: ConfigP14
    "Election parameters"
    p15: ConfigP15
    "Validators count"
    p16: ConfigP16
    "Validator stake parameters"
    p17: ConfigP17
    "Storage prices"
    p18: [ConfigP18]
    "Address of minter smart contract in the masterchain\n\nComplexity 0"
    p2: String
    "Gas limits and prices in the masterchain"
    p20: GasLimitsPrices
    "Gas limits and prices in workchains"
    p21: GasLimitsPrices
    "Block limits in the masterchain"
    p22: BlockLimits
    "Block limits in workchains"
    p23: BlockLimits
    "Message forward prices in the masterchain"
    p24: MsgForwardPrices
    "Message forward prices in workchains"
    p25: MsgForwardPrices
    "Catchain config"
    p28: ConfigP28
    "Consensus config"
    p29: ConfigP29
    "Address of fee collector smart contract in the masterchain\n\nComplexity 0"
    p3: String
    p30: ConfigP30
    "Array of fundamental smart contracts addresses\n\nComplexity 0"
    p31: [String]
    "Previous validators set"
    p32: ValidatorSet
    "Previous temporary validators set"
    p33: ValidatorSet
    "Current validators set"
    p34: ValidatorSet
    "Current temporary validators set"
    p35: ValidatorSet
    "Next validators set"
    p36: ValidatorSet
    "Next temporary validators set"
    p37: ValidatorSet
    "Array of validator signed temporary keys"
    p39: [ConfigP39]
    "Address of TON DNS root smart contract in the masterchain\n\nComplexity 0"
    p4: String
    p40: ConfigP40
    p42: ConfigP42
    "Configuration parameter 6"
    p6: ConfigP6
    "Configuration parameter 7"
    p7: [ConfigP7]
    "Global version"
    p8: ConfigP8
    "Mandatory params\n\nComplexity 0"
    p9: [Float]
}

"\nComplexity 0"
type TransactionStorage {
    "This field represents account status change after the transaction is completed.\n- 0 – unchanged\n- 1 – frozen\n- 2 – deleted\n\nComplexity 0"
    status_change: Int
    status_change_name: AccountStatusChangeEnum
    "This field defines the amount of storage fees collected in grams.\n\nComplexity 0"
    storage_fees_collected(format: BigIntFormat): String
    "This field represents the amount of due fees in grams, it might be empty.\n\nComplexity 0"
    storage_fees_due(format: BigIntFormat): String
}

"\nComplexity 0"
type TransactionCredit {
    "\nComplexity 0"
    credit(format: BigIntFormat): String
    credit_other: [OtherCurrency]
    "The sum of due_fees_collected and credit must equal the value of the message received, plus its ihr_fee if the message has not been received via Instant Hypercube Routing, IHR (otherwise the ihr_fee is awarded to the validators).\n\nComplexity 0"
    due_fees_collected(format: BigIntFormat): String
}

"\nComplexity 0"
type TransactionCompute {
    "The flag reflects whether this has resulted in the activation of a previously frozen, uninitialized or non-existent account.\n\nComplexity 0"
    account_activated: Boolean
    "- 0 – skipped\n- 1 – vm\n\nComplexity 0"
    compute_type: Int
    compute_type_name: ComputeTypeEnum
    "\nComplexity 0"
    exit_arg: Int
    "These parameter represents the status values returned by TVM; for a successful transaction, exit_code has to be 0 or 1\n\nComplexity 0"
    exit_code: Int
    "This parameter may be non-zero only for external inbound messages. It is the lesser of either the amount of gas that can be paid from the account balance or the maximum gas credit\n\nComplexity 0"
    gas_credit: Int
    "This parameter reflects the total gas fees collected by the validators for executing this transaction. It must be equal to the product of gas_used and gas_price from the current block header.\n\nComplexity 0"
    gas_fees(format: BigIntFormat): String
    "This parameter reflects the gas limit for this instance of TVM. It equals the lesser of either the Grams credited in the credit phase from the value of the inbound message divided by the current gas price, or the global per-transaction gas limit.\n\nComplexity 0"
    gas_limit(format: BigIntFormat): String
    "\nComplexity 0"
    gas_used(format: BigIntFormat): String
    "\nComplexity 0"
    mode: Int
    "This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)\n\nComplexity 0"
    msg_state_used: Boolean
    "Reason for skipping the compute phase. According to the specification, the phase can be skipped due to the absence of funds to buy gas, absence of state of an account or a message, failure to provide a valid state in the message\n- 0 – noState\n- 1 – badState\n- 2 – noGas\n\nComplexity 0"
    skipped_reason: Int
    skipped_reason_name: SkipReasonEnum
    "This flag is set if and only if exit_code is either 0 or 1.\n\nComplexity 0"
    success: Boolean
    "This parameter is the representation hashes of the resulting state of TVM.\n\nComplexity 0"
    vm_final_state_hash: String
    "This parameter is the representation hashes of the original state of TVM.\n\nComplexity 0"
    vm_init_state_hash: String
    "the total number of steps performed by TVM (usually equal to two plus the number of instructions executed, including implicit RETs)\n\nComplexity 0"
    vm_steps: Float
}

"\nComplexity 0"
type TransactionAction {
    "\nComplexity 0"
    action_list_hash: String
    "\nComplexity 0"
    msgs_created: Int
    "The flag indicates absence of funds required to create an outbound message\n\nComplexity 0"
    no_funds: Boolean
    "\nComplexity 0"
    result_arg: Int
    "\nComplexity 0"
    result_code: Int
    "\nComplexity 0"
    skipped_actions: Int
    "\nComplexity 0"
    spec_actions: Int
    "- 0 – unchanged\n- 1 – frozen\n- 2 – deleted\n\nComplexity 0"
    status_change: Int
    status_change_name: AccountStatusChangeEnum
    "\nComplexity 0"
    success: Boolean
    "\nComplexity 0"
    tot_actions: Int
    "\nComplexity 0"
    total_action_fees(format: BigIntFormat): String
    "\nComplexity 0"
    total_fwd_fees(format: BigIntFormat): String
    "\nComplexity 0"
    total_msg_size_bits: Float
    "\nComplexity 0"
    total_msg_size_cells: Float
    "\nComplexity 0"
    valid: Boolean
}

"\nComplexity 0"
type TransactionBounce {
    "- 0 – negFunds\n- 1 – noFunds\n- 2 – ok\n\nComplexity 0"
    bounce_type: Int
    bounce_type_name: BounceTypeEnum
    "\nComplexity 0"
    fwd_fees(format: BigIntFormat): String
    "\nComplexity 0"
    msg_fees(format: BigIntFormat): String
    "\nComplexity 0"
    msg_size_bits: Float
    "\nComplexity 0"
    msg_size_cells: Float
    "\nComplexity 0"
    req_fwd_fees(format: BigIntFormat): String
}

"\nComplexity 0"
type TransactionSplitInfo {
    "\nComplexity 0"
    acc_split_depth: Int
    "length of the current shard prefix\n\nComplexity 0"
    cur_shard_pfx_len: Int
    "\nComplexity 0"
    sibling_addr: String
    "\nComplexity 0"
    this_addr: String
}

"\nComplexity 7"
type BlockValueFlow {
    "\nComplexity 0"
    created(format: BigIntFormat): String
    created_other: [OtherCurrency]
    "Amount of grams exported.\n\nComplexity 0"
    exported(format: BigIntFormat): String
    "Amount of non gram cryptocurrencies exported."
    exported_other: [OtherCurrency]
    "\nComplexity 0"
    fees_collected(format: BigIntFormat): String
    fees_collected_other: [OtherCurrency]
    "Amount of import fees in grams\n\nComplexity 0"
    fees_imported(format: BigIntFormat): String
    "Amount of import fees in non gram currencies."
    fees_imported_other: [OtherCurrency]
    "Amount of grams transferred from previous block.\n\nComplexity 0"
    from_prev_blk(format: BigIntFormat): String
    "Amount of non gram cryptocurrencies transferred from previous block."
    from_prev_blk_other: [OtherCurrency]
    "Amount of grams imported.\n\nComplexity 0"
    imported(format: BigIntFormat): String
    "Amount of non gram cryptocurrencies imported."
    imported_other: [OtherCurrency]
    "Amount of grams minted in this block.\n\nComplexity 0"
    minted(format: BigIntFormat): String
    minted_other: [OtherCurrency]
    "Amount of grams amount to the next block.\n\nComplexity 0"
    to_next_blk(format: BigIntFormat): String
    "Amount of non gram cryptocurrencies to the next block."
    to_next_blk_other: [OtherCurrency]
}

"\nComplexity 0"
type BlockAccountBlocksTransactions {
    "\nComplexity 0"
    lt(format: BigIntFormat): String
    "\nComplexity 0"
    total_fees(format: BigIntFormat): String
    total_fees_other: [OtherCurrency]
    "\nComplexity 0"
    transaction_id: String
}

"\nComplexity 3"
type BlockAccountBlocks {
    "\nComplexity 0"
    account_addr: String
    "new version of block hashes\n\nComplexity 0"
    new_hash: String
    "old version of block hashes\n\nComplexity 0"
    old_hash: String
    "\nComplexity 0"
    tr_count: Int
    transactions: [BlockAccountBlocksTransactions]
}

"\nComplexity 0"
type BlockStateUpdate {
    "\nComplexity 0"
    new: String
    "\nComplexity 0"
    new_depth: Int
    "\nComplexity 0"
    new_hash: String
    "\nComplexity 0"
    old: String
    "\nComplexity 0"
    old_depth: Int
    "\nComplexity 0"
    old_hash: String
}

"Shard description\n\nComplexity 0"
type BlockMasterShardHashesDescr {
    "\nComplexity 0"
    before_merge: Boolean
    "TON Blockchain supports dynamic sharding, so the shard configuration may change from block to block because of shard merge and split events. Therefore, we cannot simply say that each shardchain corresponds to a fixed set of account chains.\nA shardchain block and its state may each be classified into two distinct parts. The parts with the ISP-dictated form of will be called the split parts of the block and its state, while the remainder will be called the non-split parts.\nThe masterchain cannot be split or merged.\n\nComplexity 0"
    before_split: Boolean
    "Logical time of the shardchain end\n\nComplexity 0"
    end_lt(format: BigIntFormat): String
    "Amount of fees collected int his shard in grams.\n\nComplexity 0"
    fees_collected(format: BigIntFormat): String
    "Amount of fees collected int his shard in non gram currencies."
    fees_collected_other: [OtherCurrency]
    "Shard block file hash.\n\nComplexity 0"
    file_hash: String
    "\nComplexity 0"
    flags: Int
    "Amount of funds created in this shard in grams.\n\nComplexity 0"
    funds_created(format: BigIntFormat): String
    "Amount of funds created in this shard in non gram currencies."
    funds_created_other: [OtherCurrency]
    "Generation time in uint32\n\nComplexity 0"
    gen_utime: Float
    "\nComplexity 0"
    gen_utime_string: String
    "\nComplexity 0"
    min_ref_mc_seqno: Float
    "\nComplexity 0"
    next_catchain_seqno: Float
    "\nComplexity 0"
    next_validator_shard: String
    "\nComplexity 0"
    nx_cc_updated: Boolean
    "Returns last known master block at the time of shard generation.\n\nComplexity 0"
    reg_mc_seqno: Float
    "Returns last known master block at the time of shard generation. The shard block configuration is derived from that block.\n\nComplexity 0"
    root_hash: String
    "uint32 sequence number\n\nComplexity 0"
    seq_no: Float
    "\nComplexity 0"
    split: Float
    "- 0 – none\n- 2 – split\n- 3 – merge\n\nComplexity 0"
    split_type: Int
    split_type_name: SplitTypeEnum
    "Logical time of the shardchain start\n\nComplexity 0"
    start_lt(format: BigIntFormat): String
    "\nComplexity 0"
    want_merge: Boolean
    "\nComplexity 0"
    want_split: Boolean
}

"\nComplexity 0"
type BlockMasterShardHashes {
    "Shard description"
    descr: BlockMasterShardHashesDescr
    "Shard ID\n\nComplexity 0"
    shard: String
    "Uint32 workchain ID\n\nComplexity 0"
    workchain_id: Int
}

"\nComplexity 0"
type BlockMasterShardFees {
    "Amount of fees created during shard\n\nComplexity 0"
    create(format: BigIntFormat): String
    "Amount of non gram fees created in non gram crypto currencies during the block."
    create_other: [OtherCurrency]
    "Amount of fees in grams\n\nComplexity 0"
    fees(format: BigIntFormat): String
    "Array of fees in non gram crypto currencies"
    fees_other: [OtherCurrency]
    "\nComplexity 0"
    shard: String
    "\nComplexity 0"
    workchain_id: Int
}

"\nComplexity 0"
type BlockMasterPrevBlkSignatures {
    "\nComplexity 0"
    node_id: String
    "\nComplexity 0"
    r: String
    "\nComplexity 0"
    s: String
}

"\nComplexity 10"
type BlockMaster {
    config: Config
    "\nComplexity 0"
    config_addr: String
    "Max block generation time of shards\n\nComplexity 0"
    max_shard_gen_utime: Float
    "\nComplexity 0"
    max_shard_gen_utime_string: String
    "Min block generation time of shards\n\nComplexity 0"
    min_shard_gen_utime: Float
    "\nComplexity 0"
    min_shard_gen_utime_string: String
    prev_blk_signatures: [BlockMasterPrevBlkSignatures]
    recover_create_msg: InMsg
    shard_fees: [BlockMasterShardFees]
    shard_hashes: [BlockMasterShardHashes]
}

"\nComplexity 0"
type BlockSignaturesSignatures {
    "\nComplexity 0"
    node_id: String
    "'R' part of signature\n\nComplexity 0"
    r: String
    "'s' part of signature\n\nComplexity 0"
    s: String
}

"\nComplexity 0"
type ZerostateMaster {
    config: Config
    "\nComplexity 0"
    config_addr: String
    "Overall balance of all accounts\n\nComplexity 0"
    global_balance(format: BigIntFormat): String
    "Overall balance of all accounts in other currencies"
    global_balance_other: [OtherCurrency]
    "\nComplexity 0"
    validator_list_hash_short: Float
}

"\nComplexity 0"
type ZerostateAccounts {
    "\nComplexity 0"
    id: String
    "Returns the current status of the account.\n```\n{\n  accounts(filter: {acc_type:{eq:1}}){\n    id\n    acc_type\n  }\n}\n```\n        \n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist\n\nComplexity 0"
    acc_type: Int
    acc_type_name: AccountStatusEnum
    "```\n{\n  accounts(orderBy:{path:\"balance\",direction:DESC}){\n    balance\n  }\n}\n```\n\nComplexity 0"
    balance(format: BigIntFormat): String
    balance_other: [OtherCurrency]
    "Contains sum of all the bits used by the cells of the account. Used in storage fee calculation\n\nComplexity 0"
    bits(format: BigIntFormat): String
    "Bag of cells with the account struct encoded as base64.\n\nComplexity 30"
    boc: String
    "Contains number of the cells of the account. Used in storage fee calculation\n\nComplexity 0"
    cells(format: BigIntFormat): String
    "If present, contains smart-contract code encoded with in base64.\n```  \n{\n  accounts (filter:{code:{eq:null}}){\n    id\n    acc_type\n  }\n}   \n```          \n\nComplexity 10"
    code: String
    "`code` field root hash.\n\nComplexity 0"
    code_hash: String
    "If present, contains smart-contract data encoded with in base64.\n\nComplexity 20"
    data: String
    "`data` field root hash.\n\nComplexity 0"
    data_hash: String
    "If present, accumulates the storage payments that could not be exacted from the balance of the account, represented by a strictly positive amount of nano tokens; it can be present only for uninitialized or frozen accounts that have a balance of zero Grams (but may have non-zero balances in non gram cryptocurrencies). When due_payment becomes larger than the value of a configurable parameter of the blockchain, the ac- count is destroyed altogether, and its balance, if any, is transferred to the zero account.\n```\n{\n  accounts(filter: { due_payment: { ne: null } })\n    {\n      id\n    }\n}\n```\n\nComplexity 0"
    due_payment(format: BigIntFormat): String
    "account 's initial code hash (when it was deployed)\n\nComplexity 0"
    init_code_hash: String
    "Contains either the unixtime of the most recent storage payment\ncollected (usually this is the unixtime of the most recent transaction),\nor the unixtime when the account was created (again, by a transaction).\n```\nquery{\n  accounts(filter: {\n    last_paid:{ge:1567296000}\n  }) {\n  id\n  last_paid}\n}\n```     \n\nComplexity 0"
    last_paid: Float
    "\nComplexity 0"
    last_trans_lt(format: BigIntFormat): String
    "If present, contains library code used in smart-contract.\n\nComplexity 0"
    library: String
    "`library` field root hash.\n\nComplexity 0"
    library_hash: String
    "\nComplexity 0"
    prev_code_hash: String
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64.\n\nComplexity 0"
    proof: String
    "Contains the number of public cells of the account. Used in storage fee calculation.\n\nComplexity 0"
    public_cells(format: BigIntFormat): String
    "Is present and non-zero only in instances of large smart contracts.\n\nComplexity 0"
    split_depth: Int
    "Contains the representation hash of an instance of `StateInit` when an account is frozen.\n\nComplexity 0"
    state_hash: String
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.\n\nComplexity 0"
    tick: Boolean
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.\n```        \n{\n  accounts (filter:{tock:{ne:null}}){\n    id\n    tock\n    tick\n  }\n}\n```\n\nComplexity 0"
    tock: Boolean
    "Workchain id of the account address (id field).\n\nComplexity 0"
    workchain_id: Int
}

"\nComplexity 0"
type ZerostateLibraries {
    "Library hash\n\nComplexity 0"
    hash: String
    "Serialized bag of cells of this library encoded with base64\n\nComplexity 0"
    lib: String
    "List of the accounts which use the library\n\nComplexity 0"
    publishers: [String]
}

"# Account type\n\nRecall that a smart contract and an account are the same thing in the context\nof the TON Blockchain, and that these terms can be used interchangeably, at\nleast as long as only small (or “usual”) smart contracts are considered. A large\nsmart-contract may employ several accounts lying in different shardchains of\nthe same workchain for load balancing purposes.\n\nAn account is identified by its full address and is completely described by\nits state. In other words, there is nothing else in an account apart from its\naddress and state.\n\nComplexity 10"
type Account {
    "\nComplexity 0"
    id: String
    "Returns the current status of the account.\n```\n{\n  accounts(filter: {acc_type:{eq:1}}){\n    id\n    acc_type\n  }\n}\n```\n        \n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist\n\nComplexity 0"
    acc_type: Int
    acc_type_name: AccountStatusEnum
    "```\n{\n  accounts(orderBy:{path:\"balance\",direction:DESC}){\n    balance\n  }\n}\n```\n\nComplexity 0"
    balance(format: BigIntFormat): String
    balance_other: [OtherCurrency]
    "Contains sum of all the bits used by the cells of the account. Used in storage fee calculation\n\nComplexity 0"
    bits(format: BigIntFormat): String
    "Bag of cells with the account struct encoded as base64.\n\nComplexity 5"
    boc: String
    "Contains number of the cells of the account. Used in storage fee calculation\n\nComplexity 0"
    cells(format: BigIntFormat): String
    "If present, contains smart-contract code encoded with in base64.\n```  \n{\n  accounts (filter:{code:{eq:null}}){\n    id\n    acc_type\n  }\n}   \n```          \n\nComplexity 2"
    code: String
    "`code` field root hash.\n\nComplexity 0"
    code_hash: String
    "If present, contains smart-contract data encoded with in base64.\n\nComplexity 3"
    data: String
    "`data` field root hash.\n\nComplexity 0"
    data_hash: String
    "If present, accumulates the storage payments that could not be exacted from the balance of the account, represented by a strictly positive amount of nano tokens; it can be present only for uninitialized or frozen accounts that have a balance of zero Grams (but may have non-zero balances in non gram cryptocurrencies). When due_payment becomes larger than the value of a configurable parameter of the blockchain, the ac- count is destroyed altogether, and its balance, if any, is transferred to the zero account.\n```\n{\n  accounts(filter: { due_payment: { ne: null } })\n    {\n      id\n    }\n}\n```\n\nComplexity 0"
    due_payment(format: BigIntFormat): String
    "account 's initial code hash (when it was deployed)\n\nComplexity 0"
    init_code_hash: String
    "Contains either the unixtime of the most recent storage payment\ncollected (usually this is the unixtime of the most recent transaction),\nor the unixtime when the account was created (again, by a transaction).\n```\nquery{\n  accounts(filter: {\n    last_paid:{ge:1567296000}\n  }) {\n  id\n  last_paid}\n}\n```     \n\nComplexity 0"
    last_paid: Float
    "\nComplexity 0"
    last_trans_lt(format: BigIntFormat): String
    "If present, contains library code used in smart-contract.\n\nComplexity 0"
    library: String
    "`library` field root hash.\n\nComplexity 0"
    library_hash: String
    "\nComplexity 0"
    prev_code_hash: String
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64.\n\nComplexity 0"
    proof: String
    "Contains the number of public cells of the account. Used in storage fee calculation.\n\nComplexity 0"
    public_cells(format: BigIntFormat): String
    "Is present and non-zero only in instances of large smart contracts.\n\nComplexity 0"
    split_depth: Int
    "Contains the representation hash of an instance of `StateInit` when an account is frozen.\n\nComplexity 0"
    state_hash: String
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.\n\nComplexity 0"
    tick: Boolean
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.\n```        \n{\n  accounts (filter:{tock:{ne:null}}){\n    id\n    tock\n    tick\n  }\n}\n```\n\nComplexity 0"
    tock: Boolean
    "Workchain id of the account address (id field).\n\nComplexity 0"
    workchain_id: Int
    tokenHolder: FungibleTokenHolder
}

"TON Transaction\n\nComplexity 10"
type Transaction {
    "\nComplexity 0"
    id: String
    "\nComplexity 0"
    aborted: Boolean
    account(timeout: Int "**DEPRECATED**" when: TransactionFilter): Account
    "\nComplexity 0"
    account_addr: String
    action: TransactionAction
    "Account balance change after the transaction.\nBecause fwd_fee is collected by the validators of the receiving shard, \ntotal_fees value does not include Sum(out_msg.fwd_fee[]), but includes in_msg.fwd_fee.\n\nThe formula is:\nbalance_delta = in_msg.value - total_fees - Sum(out_msg.value[]) - Sum(out_msg.fwd_fee[])\n\nComplexity 0"
    balance_delta(format: BigIntFormat): String
    "Account balance change after the transaction.\nBecause fwd_fee is collected by the validators of the receiving shard, \ntotal_fees value does not include Sum(out_msg.fwd_fee[]), but includes in_msg.fwd_fee.\n\nThe formula is:\nbalance_delta = in_msg.value - total_fees - Sum(out_msg.value[]) - Sum(out_msg.fwd_fee[])"
    balance_delta_other: [OtherCurrency]
    block(timeout: Int "**DEPRECATED**" when: TransactionFilter): Block
    "\nComplexity 0"
    block_id: String
    "\nComplexity 4"
    boc: String
    bounce: TransactionBounce
    "Collection-unique field for pagination and sorting. This field is designed to retain logical order.\n\nComplexity 0"
    chain_order: String
    compute: TransactionCompute
    credit: TransactionCredit
    "\nComplexity 0"
    credit_first: Boolean
    "\nComplexity 0"
    destroyed: Boolean
    "The end state of an account after a transaction, 1 is returned to indicate a finalized transaction at an active account\n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist\n\nComplexity 0"
    end_status: Int
    end_status_name: AccountStatusEnum
    "Fee for inbound external message import.\n\nComplexity 0"
    ext_in_msg_fee(format: BigIntFormat): String
    in_message(timeout: Int "**DEPRECATED**" when: TransactionFilter): Message
    "\nComplexity 0"
    in_msg: String
    "\nComplexity 0"
    installed: Boolean
    "Logical time. A component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see [the TON blockchain specification](https:\/\/test.ton.org\/tblkch.pdf).\n\nComplexity 0"
    lt(format: BigIntFormat): String
    "Merkle update field\n\nComplexity 0"
    new_hash: String
    "\nComplexity 0"
    now: Float
    "\nComplexity 0"
    now_string: String
    "Merkle update field\n\nComplexity 0"
    old_hash: String
    "The initial state of account. Note that in this case the query may return 0, if the account was not active before the transaction and 1 if it was already active\n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist\n\nComplexity 0"
    orig_status: Int
    orig_status_name: AccountStatusEnum
    out_messages(timeout: Int "**DEPRECATED**" when: TransactionFilter): [Message]
    "\nComplexity 0"
    out_msgs: [String]
    "The number of generated outbound messages (one of the common transaction parameters defined by the specification)\n\nComplexity 0"
    outmsg_cnt: Int
    "\nComplexity 0"
    prepare_transaction: String
    "\nComplexity 0"
    prev_trans_hash: String
    "\nComplexity 0"
    prev_trans_lt(format: BigIntFormat): String
    "\nComplexity 0"
    proof: String
    split_info: TransactionSplitInfo
    "Transaction processing status\n- 0 – unknown\n- 1 – preliminary\n- 2 – proposed\n- 3 – finalized\n- 4 – refused\n\nComplexity 0"
    status: Int
    status_name: TransactionProcessingStatusEnum
    storage: TransactionStorage
    "Total amount of fees collected by the validators. \nBecause fwd_fee is collected by the validators of the receiving shard, \ntotal_fees value does not include Sum(out_msg.fwd_fee[]), but includes in_msg.fwd_fee.\nThe formula is:\ntotal_fees = in_msg.value - balance_delta - Sum(out_msg.value[]) - Sum(out_msg.fwd_fee[])\n\nComplexity 0"
    total_fees(format: BigIntFormat): String
    "Same as above, but reserved for non gram coins that may appear in the blockchain"
    total_fees_other: [OtherCurrency]
    "Transaction type according to the original blockchain specification, clause 4.2.4.\n- 0 – ordinary\n- 1 – storage\n- 2 – tick\n- 3 – tock\n- 4 – splitPrepare\n- 5 – splitInstall\n- 6 – mergePrepare\n- 7 – mergeInstall\n\nComplexity 0"
    tr_type: Int
    tr_type_name: TransactionTypeEnum
    "\nComplexity 0"
    tt: String
    "Workchain id of the account address (account_addr field)\n\nComplexity 0"
    workchain_id: Int
    tokenTransfer: FungibleTokenTransfer
}

"# Message type\n\nMessage layout queries.  A message consists of its header followed by its\nbody or payload. The body is essentially arbitrary, to be interpreted by the\ndestination smart contract. It can be queried with the following fields:\n\nComplexity 5"
type Message {
    "\nComplexity 0"
    id: String
    block(timeout: Int "**DEPRECATED**" when: MessageFilter): Block
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64.\n\nComplexity 0"
    block_id: String
    "A bag of cells with the message structure encoded as base64.\n\nComplexity 3"
    boc: String
    "Bag of cells with the message body encoded as base64.\n\nComplexity 0"
    body: String
    "`body` field root hash.\n\nComplexity 0"
    body_hash: String
    "Bounce flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender.\n\nComplexity 0"
    bounce: Boolean
    "Bounced flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender.\n\nComplexity 0"
    bounced: Boolean
    "Collection-unique field for pagination and sorting. This field is designed to retain logical output order (for logical input order use transaction.in_message).\n\nComplexity 0"
    chain_order: String
    "Represents contract code in deploy messages.\n\nComplexity 1"
    code: String
    "`code` field root hash.\n\nComplexity 0"
    code_hash: String
    "Creation unixtime automatically set by the generating transaction. The creation unixtime equals the creation unixtime of the block containing the generating transaction.\n\nComplexity 0"
    created_at: Float
    "\nComplexity 0"
    created_at_string: String
    "Logical creation time automatically set by the generating transaction.\n\nComplexity 0"
    created_lt(format: BigIntFormat): String
    "Represents initial data for a contract in deploy messages\n\nComplexity 2"
    data: String
    "`data` field root hash.\n\nComplexity 0"
    data_hash: String
    "Returns destination address string\n\nComplexity 0"
    dst: String
    dst_account(timeout: Int "**DEPRECATED**" when: MessageFilter): Account
    dst_transaction(timeout: Int "**DEPRECATED**" when: MessageFilter): Transaction
    "Workchain id of the destination address (dst field)\n\nComplexity 0"
    dst_workchain_id: Int
    "Original total forwarding fee paid for using the HR mechanism; it is automatically computed from some configuration parameters and the size of the message at the time the message is generated.\n\nComplexity 0"
    fwd_fee(format: BigIntFormat): String
    "IHR is disabled for the message.\n\nComplexity 0"
    ihr_disabled: Boolean
    "This value is subtracted from the value attached to the message and awarded to the validators of the destination shardchain if they include the message by the IHR mechanism.\n\nComplexity 0"
    ihr_fee(format: BigIntFormat): String
    "\nComplexity 0"
    import_fee(format: BigIntFormat): String
    "Represents contract library in deploy messages\n\nComplexity 0"
    library: String
    "`library` field root hash.\n\nComplexity 0"
    library_hash: String
    "Returns the type of message.\n- 0 – internal\n- 1 – extIn\n- 2 – extOut\n\nComplexity 0"
    msg_type: Int
    msg_type_name: MessageTypeEnum
    "Merkle proof that message is a part of a block it cut from. It is a bag of cells with Merkle proof struct encoded as base64.\n\nComplexity 0"
    proof: String
    "This is only used for special contracts in masterchain to deploy messages.\n\nComplexity 0"
    split_depth: Int
    "Returns source address string\n\nComplexity 0"
    src: String
    src_account(timeout: Int "**DEPRECATED**" when: MessageFilter): Account
    src_transaction(timeout: Int "**DEPRECATED**" when: MessageFilter): Transaction
    "Workchain id of the source address (src field)\n\nComplexity 0"
    src_workchain_id: Int
    "Returns internal processing status according to the numbers shown.\n- 0 – unknown\n- 1 – queued\n- 2 – processing\n- 3 – preliminary\n- 4 – proposed\n- 5 – finalized\n- 6 – refused\n- 7 – transiting\n\nComplexity 0"
    status: Int
    status_name: MessageProcessingStatusEnum
    "This is only used for special contracts in masterchain to deploy messages.\n\nComplexity 0"
    tick: Boolean
    "This is only used for special contracts in masterchain to deploy messages\n\nComplexity 0"
    tock: Boolean
    "May or may not be present\n\nComplexity 0"
    value(format: BigIntFormat): String
    "May or may not be present."
    value_other: [OtherCurrency]
    tokenTransfer: FungibleTokenTransfer
}

"This is Block\n\nComplexity 15"
type Block {
    "\nComplexity 0"
    id: String
    account_blocks: [BlockAccountBlocks]
    "\nComplexity 0"
    after_merge: Boolean
    "\nComplexity 0"
    after_split: Boolean
    "\nComplexity 0"
    before_split: Boolean
    "Serialized bag of cells of this block encoded with base64\n\nComplexity 10"
    boc: String
    "Collection-unique field for pagination and sorting. This field is designed to retain logical order.\n\nComplexity 0"
    chain_order: String
    "Public key of the collator who produced this block.\n\nComplexity 0"
    created_by: String
    "Logical creation time automatically set by the block formation end.\n\nComplexity 0"
    end_lt(format: BigIntFormat): String
    "Block file hash\n\nComplexity 0"
    file_hash: String
    "\nComplexity 0"
    flags: Int
    "\nComplexity 0"
    gen_catchain_seqno: Float
    "\nComplexity 0"
    gen_software_capabilities(format: BigIntFormat): String
    "\nComplexity 0"
    gen_software_version: Float
    "uint 32 generation time stamp\n\nComplexity 0"
    gen_utime: Float
    "\nComplexity 0"
    gen_utime_string: String
    "\nComplexity 0"
    gen_validator_list_hash_short: Float
    "uint32 global block ID\n\nComplexity 0"
    global_id: Int
    in_msg_descr: [InMsg]
    "true if this block is a key block\n\nComplexity 0"
    key_block: Boolean
    master: BlockMaster
    master_ref: ExtBlkRef
    "Returns last known master block at the time of shard generation.\n\nComplexity 0"
    min_ref_mc_seqno: Float
    out_msg_descr: [OutMsg]
    "External block reference for previous block in case of shard merge."
    prev_alt_ref: ExtBlkRef
    "Returns a number of a previous key block.\n\nComplexity 0"
    prev_key_block_seqno: Float
    "External block reference for previous block."
    prev_ref: ExtBlkRef
    prev_vert_alt_ref: ExtBlkRef
    "External block reference for previous block in case of vertical blocks."
    prev_vert_ref: ExtBlkRef
    "\nComplexity 0"
    rand_seed: String
    "\nComplexity 0"
    seq_no: Float
    "\nComplexity 0"
    shard: String
    signatures(timeout: Int "**DEPRECATED**" when: BlockFilter): BlockSignatures
    "Logical creation time automatically set by the block formation start.\nLogical time is a component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see the TON blockchain specification\n\nComplexity 0"
    start_lt(format: BigIntFormat): String
    state_update: BlockStateUpdate
    "Returns block processing status\n- 0 – unknown\n- 1 – proposed\n- 2 – finalized\n- 3 – refused\n\nComplexity 0"
    status: Int
    status_name: BlockProcessingStatusEnum
    "\nComplexity 0"
    tr_count: Int
    value_flow: BlockValueFlow
    "uin32 block version identifier\n\nComplexity 0"
    version: Float
    "\nComplexity 0"
    vert_seq_no: Float
    "\nComplexity 0"
    want_merge: Boolean
    "\nComplexity 0"
    want_split: Boolean
    "uint32 workchain identifier\n\nComplexity 0"
    workchain_id: Int
}

"Set of validator's signatures for the Block with correspond id\n\nComplexity 5"
type BlockSignatures {
    "\nComplexity 0"
    id: String
    block(timeout: Int "**DEPRECATED**" when: BlockSignaturesFilter): Block
    "\nComplexity 0"
    catchain_seqno: Float
    "Signed block's gen_utime\n\nComplexity 0"
    gen_utime: Float
    "\nComplexity 0"
    gen_utime_string: String
    "Signed block's merkle proof\n\nComplexity 0"
    proof: String
    "Signed block's seq_no\n\nComplexity 0"
    seq_no: Float
    "Signed block's shard\n\nComplexity 0"
    shard: String
    "\nComplexity 0"
    sig_weight(format: BigIntFormat): String
    "Array of signatures from block's validators"
    signatures: [BlockSignaturesSignatures]
    "\nComplexity 0"
    validator_list_hash_short: Float
    "Signed block's workchain_id\n\nComplexity 0"
    workchain_id: Int
}

"The initial state of the workchain before first block was generated\n\nComplexity 60"
type Zerostate {
    "\nComplexity 0"
    id: String
    "Initial accounts state at the workchain start"
    accounts: [ZerostateAccounts]
    "Serialized bag of cells of this zerostate encoded with base64\n\nComplexity 20"
    boc: String
    "Zerostate file hash\n\nComplexity 0"
    file_hash: String
    "uint32 global network ID\n\nComplexity 0"
    global_id: Int
    "Initial libraries at the workchain start"
    libraries: [ZerostateLibraries]
    master: ZerostateMaster
    "Zerostate root cell representation hash\n\nComplexity 0"
    root_hash: String
    "Overall balance of all accounts of the workchain\n\nComplexity 0"
    total_balance(format: BigIntFormat): String
    "Overall balance of all accounts of the workchain in other currencies"
    total_balance_other: [OtherCurrency]
    "Zerostate workchain_id\n\nComplexity 0"
    workchain_id: Int
}

input OtherCurrencyFilter {
    currency: FloatFilter
    value: StringFilter
    OR: OtherCurrencyFilter
}

input ExtBlkRefFilter {
    end_lt: StringFilter
    file_hash: StringFilter
    root_hash: StringFilter
    seq_no: FloatFilter
    OR: ExtBlkRefFilter
}

input MsgEnvelopeFilter {
    cur_addr: StringFilter
    fwd_fee_remaining: StringFilter
    msg_id: StringFilter
    next_addr: StringFilter
    OR: MsgEnvelopeFilter
}

input InMsgTypeEnumFilter {
    eq: InMsgTypeEnum
    ne: InMsgTypeEnum
    gt: InMsgTypeEnum
    lt: InMsgTypeEnum
    ge: InMsgTypeEnum
    le: InMsgTypeEnum
    in: [InMsgTypeEnum]
    notIn: [InMsgTypeEnum]
}

input InMsgFilter {
    fwd_fee: StringFilter
    ihr_fee: StringFilter
    in_msg: MsgEnvelopeFilter
    msg_id: StringFilter
    "- 0 – external\n- 1 – ihr\n- 2 – immediately\n- 3 – final\n- 4 – transit\n- 5 – discardedFinal\n- 6 – discardedTransit"
    msg_type: IntFilter
    msg_type_name: InMsgTypeEnumFilter
    out_msg: MsgEnvelopeFilter
    proof_created: StringFilter
    proof_delivered: StringFilter
    transaction_id: StringFilter
    transit_fee: StringFilter
    OR: InMsgFilter
}

input OutMsgTypeEnumFilter {
    eq: OutMsgTypeEnum
    ne: OutMsgTypeEnum
    gt: OutMsgTypeEnum
    lt: OutMsgTypeEnum
    ge: OutMsgTypeEnum
    le: OutMsgTypeEnum
    in: [OutMsgTypeEnum]
    notIn: [OutMsgTypeEnum]
}

input OutMsgFilter {
    import_block_lt: StringFilter
    imported: InMsgFilter
    msg_env_hash: StringFilter
    msg_id: StringFilter
    "- 0 – external\n- 1 – immediately\n- 2 – outMsgNew\n- 3 – transit\n- 4 – dequeueImmediately\n- 5 – dequeue\n- 6 – transitRequired\n- 7 – dequeueShort\n- -1 – none"
    msg_type: IntFilter
    msg_type_name: OutMsgTypeEnumFilter
    next_addr_pfx: StringFilter
    next_workchain: IntFilter
    out_msg: MsgEnvelopeFilter
    reimport: InMsgFilter
    transaction_id: StringFilter
    OR: OutMsgFilter
}

input GasLimitsPricesFilter {
    block_gas_limit: StringFilter
    delete_due_limit: StringFilter
    flat_gas_limit: StringFilter
    flat_gas_price: StringFilter
    freeze_due_limit: StringFilter
    gas_credit: StringFilter
    gas_limit: StringFilter
    gas_price: StringFilter
    special_gas_limit: StringFilter
    OR: GasLimitsPricesFilter
}

input BlockLimitsBytesFilter {
    hard_limit: FloatFilter
    soft_limit: FloatFilter
    underload: FloatFilter
    OR: BlockLimitsBytesFilter
}

input BlockLimitsGasFilter {
    hard_limit: FloatFilter
    soft_limit: FloatFilter
    underload: FloatFilter
    OR: BlockLimitsGasFilter
}

input BlockLimitsLtDeltaFilter {
    hard_limit: FloatFilter
    soft_limit: FloatFilter
    underload: FloatFilter
    OR: BlockLimitsLtDeltaFilter
}

input BlockLimitsFilter {
    bytes: BlockLimitsBytesFilter
    gas: BlockLimitsGasFilter
    lt_delta: BlockLimitsLtDeltaFilter
    OR: BlockLimitsFilter
}

input MsgForwardPricesFilter {
    bit_price: StringFilter
    cell_price: StringFilter
    first_frac: IntFilter
    ihr_price_factor: FloatFilter
    lump_price: StringFilter
    next_frac: IntFilter
    OR: MsgForwardPricesFilter
}

input ValidatorSetListFilter {
    adnl_addr: StringFilter
    public_key: StringFilter
    weight: StringFilter
    OR: ValidatorSetListFilter
}

input ValidatorSetListArrayFilter {
    any: ValidatorSetListFilter
    all: ValidatorSetListFilter
}

input ValidatorSetFilter {
    list: ValidatorSetListArrayFilter
    main: IntFilter
    total: IntFilter
    total_weight: StringFilter
    utime_since: FloatFilter
    utime_until: FloatFilter
    OR: ValidatorSetFilter
}

input ConfigProposalSetupFilter {
    bit_price: FloatFilter
    cell_price: FloatFilter
    max_losses: IntFilter
    max_store_sec: FloatFilter
    max_tot_rounds: IntFilter
    min_store_sec: FloatFilter
    min_tot_rounds: IntFilter
    min_wins: IntFilter
    OR: ConfigProposalSetupFilter
}

"Configuration parameter 6"
input ConfigP6Filter {
    mint_add_price: StringFilter
    mint_new_price: StringFilter
    OR: ConfigP6Filter
}

input ConfigP7Filter {
    currency: FloatFilter
    value: StringFilter
    OR: ConfigP7Filter
}

"Global version"
input ConfigP8Filter {
    "- 0x0 – CapNone\n- 0x1 – CapIhrEnabled\n- 0x2 – CapCreateStatsEnabled\n- 0x4 – CapBounceMsgBody\n- 0x8 – CapReportVersion\n- 0x10 – CapSplitMergeTransactions\n- 0x20 – CapShortDequeue\n- 0x40 – CapMbppEnabled\n- 0x80 – CapFastStorageStat\n- 0x100 – CapInitCodeHash\n- 0x200 – CapOffHypercube\n- 0x400 – CapMyCode\n- 0x800 – CapSetLibCode\n- 0x1000 – CapFixTupleIndexBug\n- 0x2000 – CapRemp\n- 0x4000 – CapDElections\n- 0x10000 – CapFullBodyInBounced\n- 0x20000 – CapStorageFeeToTvm\n- 0x40000 – CapCopyleft\n- 0x80000 – CapIndexAccounts\n- 0x100000 – CapDiff\n- 0x200000 – CapsTvmBugfixes2022\n- 0x400000 – CapWorkchains\n- 0x800000 – CapStcontNewFormat\n- 0x1000000 – CapFastStorageStatBugfix\n- 0x2000000 – CapResolveMerkleCell\n- 0x4000000 – CapSignatureWithId"
    capabilities: StringFilter
    version: FloatFilter
    OR: ConfigP8Filter
}

"Config voting setup"
input ConfigP11Filter {
    critical_params: ConfigProposalSetupFilter
    normal_params: ConfigProposalSetupFilter
    OR: ConfigP11Filter
}

input ConfigP12Filter {
    accept_msgs: BooleanFilter
    active: BooleanFilter
    actual_min_split: IntFilter
    addr_len_step: IntFilter
    basic: BooleanFilter
    enabled_since: FloatFilter
    flags: IntFilter
    max_addr_len: IntFilter
    max_split: IntFilter
    min_addr_len: IntFilter
    min_split: IntFilter
    version: FloatFilter
    vm_mode: StringFilter
    vm_version: IntFilter
    workchain_id: IntFilter
    workchain_type_id: FloatFilter
    zerostate_file_hash: StringFilter
    zerostate_root_hash: StringFilter
    OR: ConfigP12Filter
}

"Block create fees"
input ConfigP14Filter {
    basechain_block_fee: StringFilter
    masterchain_block_fee: StringFilter
    OR: ConfigP14Filter
}

"Election parameters"
input ConfigP15Filter {
    elections_end_before: FloatFilter
    elections_start_before: FloatFilter
    stake_held_for: FloatFilter
    validators_elected_for: FloatFilter
    OR: ConfigP15Filter
}

"Validators count"
input ConfigP16Filter {
    max_main_validators: IntFilter
    max_validators: IntFilter
    min_validators: IntFilter
    OR: ConfigP16Filter
}

"Validator stake parameters"
input ConfigP17Filter {
    max_stake: StringFilter
    max_stake_factor: FloatFilter
    min_stake: StringFilter
    min_total_stake: StringFilter
    OR: ConfigP17Filter
}

input ConfigP18Filter {
    bit_price_ps: StringFilter
    cell_price_ps: StringFilter
    mc_bit_price_ps: StringFilter
    mc_cell_price_ps: StringFilter
    utime_since: FloatFilter
    OR: ConfigP18Filter
}

"Catchain config"
input ConfigP28Filter {
    mc_catchain_lifetime: FloatFilter
    shard_catchain_lifetime: FloatFilter
    shard_validators_lifetime: FloatFilter
    shard_validators_num: FloatFilter
    shuffle_mc_validators: BooleanFilter
    OR: ConfigP28Filter
}

"Consensus config"
input ConfigP29Filter {
    attempt_duration: FloatFilter
    catchain_max_deps: FloatFilter
    consensus_timeout_ms: FloatFilter
    fast_attempts: FloatFilter
    max_block_bytes: FloatFilter
    max_collated_bytes: FloatFilter
    new_catchain_ids: BooleanFilter
    next_candidate_delay_ms: FloatFilter
    round_candidates: FloatFilter
    OR: ConfigP29Filter
}

input ConfigP30Filter {
    delections_step: FloatFilter
    staker_init_code_hash: StringFilter
    validator_init_code_hash: StringFilter
    OR: ConfigP30Filter
}

input ConfigP39Filter {
    adnl_addr: StringFilter
    map_key: StringFilter
    seqno: FloatFilter
    signature_r: StringFilter
    signature_s: StringFilter
    temp_public_key: StringFilter
    valid_until: FloatFilter
    OR: ConfigP39Filter
}

input ConfigP40Filter {
    collations_score_weight: FloatFilter
    min_samples_count: FloatFilter
    min_slashing_protection_score: FloatFilter
    resend_mc_blocks_count: FloatFilter
    signing_score_weight: FloatFilter
    slashing_period_mc_blocks_count: FloatFilter
    z_param_denominator: FloatFilter
    z_param_numerator: FloatFilter
    OR: ConfigP40Filter
}

input ConfigP42PayoutsFilter {
    license_type: IntFilter
    payout_percent: IntFilter
    OR: ConfigP42PayoutsFilter
}

input ConfigP42PayoutsArrayFilter {
    any: ConfigP42PayoutsFilter
    all: ConfigP42PayoutsFilter
}

input ConfigP42Filter {
    payouts: ConfigP42PayoutsArrayFilter
    threshold: StringFilter
    OR: ConfigP42Filter
}

input FloatArrayFilter {
    any: FloatFilter
    all: FloatFilter
}

input ConfigP12ArrayFilter {
    any: ConfigP12Filter
    all: ConfigP12Filter
}

input ConfigP18ArrayFilter {
    any: ConfigP18Filter
    all: ConfigP18Filter
}

input StringArrayFilter {
    any: StringFilter
    all: StringFilter
}

input ConfigP39ArrayFilter {
    any: ConfigP39Filter
    all: ConfigP39Filter
}

input ConfigP7ArrayFilter {
    any: ConfigP7Filter
    all: ConfigP7Filter
}

input ConfigFilter {
    "Address of config smart contract in the masterchain"
    p0: StringFilter
    "Address of elector smart contract in the masterchain"
    p1: StringFilter
    "Critical params"
    p10: FloatArrayFilter
    "Config voting setup"
    p11: ConfigP11Filter
    "Array of all workchains descriptions"
    p12: ConfigP12ArrayFilter
    "Block create fees"
    p14: ConfigP14Filter
    "Election parameters"
    p15: ConfigP15Filter
    "Validators count"
    p16: ConfigP16Filter
    "Validator stake parameters"
    p17: ConfigP17Filter
    "Storage prices"
    p18: ConfigP18ArrayFilter
    "Address of minter smart contract in the masterchain"
    p2: StringFilter
    "Gas limits and prices in the masterchain"
    p20: GasLimitsPricesFilter
    "Gas limits and prices in workchains"
    p21: GasLimitsPricesFilter
    "Block limits in the masterchain"
    p22: BlockLimitsFilter
    "Block limits in workchains"
    p23: BlockLimitsFilter
    "Message forward prices in the masterchain"
    p24: MsgForwardPricesFilter
    "Message forward prices in workchains"
    p25: MsgForwardPricesFilter
    "Catchain config"
    p28: ConfigP28Filter
    "Consensus config"
    p29: ConfigP29Filter
    "Address of fee collector smart contract in the masterchain"
    p3: StringFilter
    p30: ConfigP30Filter
    "Array of fundamental smart contracts addresses"
    p31: StringArrayFilter
    "Previous validators set"
    p32: ValidatorSetFilter
    "Previous temporary validators set"
    p33: ValidatorSetFilter
    "Current validators set"
    p34: ValidatorSetFilter
    "Current temporary validators set"
    p35: ValidatorSetFilter
    "Next validators set"
    p36: ValidatorSetFilter
    "Next temporary validators set"
    p37: ValidatorSetFilter
    "Array of validator signed temporary keys"
    p39: ConfigP39ArrayFilter
    "Address of TON DNS root smart contract in the masterchain"
    p4: StringFilter
    p40: ConfigP40Filter
    p42: ConfigP42Filter
    "Configuration parameter 6"
    p6: ConfigP6Filter
    "Configuration parameter 7"
    p7: ConfigP7ArrayFilter
    "Global version"
    p8: ConfigP8Filter
    "Mandatory params"
    p9: FloatArrayFilter
    OR: ConfigFilter
}

input AccountStatusChangeEnumFilter {
    eq: AccountStatusChangeEnum
    ne: AccountStatusChangeEnum
    gt: AccountStatusChangeEnum
    lt: AccountStatusChangeEnum
    ge: AccountStatusChangeEnum
    le: AccountStatusChangeEnum
    in: [AccountStatusChangeEnum]
    notIn: [AccountStatusChangeEnum]
}

input TransactionStorageFilter {
    "This field represents account status change after the transaction is completed.\n- 0 – unchanged\n- 1 – frozen\n- 2 – deleted"
    status_change: IntFilter
    status_change_name: AccountStatusChangeEnumFilter
    "This field defines the amount of storage fees collected in grams."
    storage_fees_collected: StringFilter
    "This field represents the amount of due fees in grams, it might be empty."
    storage_fees_due: StringFilter
    OR: TransactionStorageFilter
}

input OtherCurrencyArrayFilter {
    any: OtherCurrencyFilter
    all: OtherCurrencyFilter
}

input TransactionCreditFilter {
    credit: StringFilter
    credit_other: OtherCurrencyArrayFilter
    "The sum of due_fees_collected and credit must equal the value of the message received, plus its ihr_fee if the message has not been received via Instant Hypercube Routing, IHR (otherwise the ihr_fee is awarded to the validators)."
    due_fees_collected: StringFilter
    OR: TransactionCreditFilter
}

input ComputeTypeEnumFilter {
    eq: ComputeTypeEnum
    ne: ComputeTypeEnum
    gt: ComputeTypeEnum
    lt: ComputeTypeEnum
    ge: ComputeTypeEnum
    le: ComputeTypeEnum
    in: [ComputeTypeEnum]
    notIn: [ComputeTypeEnum]
}

input SkipReasonEnumFilter {
    eq: SkipReasonEnum
    ne: SkipReasonEnum
    gt: SkipReasonEnum
    lt: SkipReasonEnum
    ge: SkipReasonEnum
    le: SkipReasonEnum
    in: [SkipReasonEnum]
    notIn: [SkipReasonEnum]
}

input TransactionComputeFilter {
    "The flag reflects whether this has resulted in the activation of a previously frozen, uninitialized or non-existent account."
    account_activated: BooleanFilter
    "- 0 – skipped\n- 1 – vm"
    compute_type: IntFilter
    compute_type_name: ComputeTypeEnumFilter
    exit_arg: IntFilter
    "These parameter represents the status values returned by TVM; for a successful transaction, exit_code has to be 0 or 1"
    exit_code: IntFilter
    "This parameter may be non-zero only for external inbound messages. It is the lesser of either the amount of gas that can be paid from the account balance or the maximum gas credit"
    gas_credit: IntFilter
    "This parameter reflects the total gas fees collected by the validators for executing this transaction. It must be equal to the product of gas_used and gas_price from the current block header."
    gas_fees: StringFilter
    "This parameter reflects the gas limit for this instance of TVM. It equals the lesser of either the Grams credited in the credit phase from the value of the inbound message divided by the current gas price, or the global per-transaction gas limit."
    gas_limit: StringFilter
    gas_used: StringFilter
    mode: IntFilter
    "This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)This parameter reflects whether the state passed in the message has been used. If it is set, the account_activated flag is used (see below)"
    msg_state_used: BooleanFilter
    "Reason for skipping the compute phase. According to the specification, the phase can be skipped due to the absence of funds to buy gas, absence of state of an account or a message, failure to provide a valid state in the message\n- 0 – noState\n- 1 – badState\n- 2 – noGas"
    skipped_reason: IntFilter
    skipped_reason_name: SkipReasonEnumFilter
    "This flag is set if and only if exit_code is either 0 or 1."
    success: BooleanFilter
    "This parameter is the representation hashes of the resulting state of TVM."
    vm_final_state_hash: StringFilter
    "This parameter is the representation hashes of the original state of TVM."
    vm_init_state_hash: StringFilter
    "the total number of steps performed by TVM (usually equal to two plus the number of instructions executed, including implicit RETs)"
    vm_steps: FloatFilter
    OR: TransactionComputeFilter
}

input TransactionActionFilter {
    action_list_hash: StringFilter
    msgs_created: IntFilter
    "The flag indicates absence of funds required to create an outbound message"
    no_funds: BooleanFilter
    result_arg: IntFilter
    result_code: IntFilter
    skipped_actions: IntFilter
    spec_actions: IntFilter
    "- 0 – unchanged\n- 1 – frozen\n- 2 – deleted"
    status_change: IntFilter
    status_change_name: AccountStatusChangeEnumFilter
    success: BooleanFilter
    tot_actions: IntFilter
    total_action_fees: StringFilter
    total_fwd_fees: StringFilter
    total_msg_size_bits: FloatFilter
    total_msg_size_cells: FloatFilter
    valid: BooleanFilter
    OR: TransactionActionFilter
}

input BounceTypeEnumFilter {
    eq: BounceTypeEnum
    ne: BounceTypeEnum
    gt: BounceTypeEnum
    lt: BounceTypeEnum
    ge: BounceTypeEnum
    le: BounceTypeEnum
    in: [BounceTypeEnum]
    notIn: [BounceTypeEnum]
}

input TransactionBounceFilter {
    "- 0 – negFunds\n- 1 – noFunds\n- 2 – ok"
    bounce_type: IntFilter
    bounce_type_name: BounceTypeEnumFilter
    fwd_fees: StringFilter
    msg_fees: StringFilter
    msg_size_bits: FloatFilter
    msg_size_cells: FloatFilter
    req_fwd_fees: StringFilter
    OR: TransactionBounceFilter
}

input TransactionSplitInfoFilter {
    acc_split_depth: IntFilter
    "length of the current shard prefix"
    cur_shard_pfx_len: IntFilter
    sibling_addr: StringFilter
    this_addr: StringFilter
    OR: TransactionSplitInfoFilter
}

input BlockValueFlowFilter {
    created: StringFilter
    created_other: OtherCurrencyArrayFilter
    "Amount of grams exported."
    exported: StringFilter
    "Amount of non gram cryptocurrencies exported."
    exported_other: OtherCurrencyArrayFilter
    fees_collected: StringFilter
    fees_collected_other: OtherCurrencyArrayFilter
    "Amount of import fees in grams"
    fees_imported: StringFilter
    "Amount of import fees in non gram currencies."
    fees_imported_other: OtherCurrencyArrayFilter
    "Amount of grams transferred from previous block."
    from_prev_blk: StringFilter
    "Amount of non gram cryptocurrencies transferred from previous block."
    from_prev_blk_other: OtherCurrencyArrayFilter
    "Amount of grams imported."
    imported: StringFilter
    "Amount of non gram cryptocurrencies imported."
    imported_other: OtherCurrencyArrayFilter
    "Amount of grams minted in this block."
    minted: StringFilter
    minted_other: OtherCurrencyArrayFilter
    "Amount of grams amount to the next block."
    to_next_blk: StringFilter
    "Amount of non gram cryptocurrencies to the next block."
    to_next_blk_other: OtherCurrencyArrayFilter
    OR: BlockValueFlowFilter
}

input BlockAccountBlocksTransactionsFilter {
    lt: StringFilter
    total_fees: StringFilter
    total_fees_other: OtherCurrencyArrayFilter
    transaction_id: StringFilter
    OR: BlockAccountBlocksTransactionsFilter
}

input BlockAccountBlocksTransactionsArrayFilter {
    any: BlockAccountBlocksTransactionsFilter
    all: BlockAccountBlocksTransactionsFilter
}

input BlockAccountBlocksFilter {
    account_addr: StringFilter
    "new version of block hashes"
    new_hash: StringFilter
    "old version of block hashes"
    old_hash: StringFilter
    tr_count: IntFilter
    transactions: BlockAccountBlocksTransactionsArrayFilter
    OR: BlockAccountBlocksFilter
}

input BlockStateUpdateFilter {
    new: StringFilter
    new_depth: IntFilter
    new_hash: StringFilter
    old: StringFilter
    old_depth: IntFilter
    old_hash: StringFilter
    OR: BlockStateUpdateFilter
}

input SplitTypeEnumFilter {
    eq: SplitTypeEnum
    ne: SplitTypeEnum
    gt: SplitTypeEnum
    lt: SplitTypeEnum
    ge: SplitTypeEnum
    le: SplitTypeEnum
    in: [SplitTypeEnum]
    notIn: [SplitTypeEnum]
}

"Shard description"
input BlockMasterShardHashesDescrFilter {
    before_merge: BooleanFilter
    "TON Blockchain supports dynamic sharding, so the shard configuration may change from block to block because of shard merge and split events. Therefore, we cannot simply say that each shardchain corresponds to a fixed set of account chains.\nA shardchain block and its state may each be classified into two distinct parts. The parts with the ISP-dictated form of will be called the split parts of the block and its state, while the remainder will be called the non-split parts.\nThe masterchain cannot be split or merged."
    before_split: BooleanFilter
    "Logical time of the shardchain end"
    end_lt: StringFilter
    "Amount of fees collected int his shard in grams."
    fees_collected: StringFilter
    "Amount of fees collected int his shard in non gram currencies."
    fees_collected_other: OtherCurrencyArrayFilter
    "Shard block file hash."
    file_hash: StringFilter
    flags: IntFilter
    "Amount of funds created in this shard in grams."
    funds_created: StringFilter
    "Amount of funds created in this shard in non gram currencies."
    funds_created_other: OtherCurrencyArrayFilter
    "Generation time in uint32"
    gen_utime: FloatFilter
    min_ref_mc_seqno: FloatFilter
    next_catchain_seqno: FloatFilter
    next_validator_shard: StringFilter
    nx_cc_updated: BooleanFilter
    "Returns last known master block at the time of shard generation."
    reg_mc_seqno: FloatFilter
    "Returns last known master block at the time of shard generation. The shard block configuration is derived from that block."
    root_hash: StringFilter
    "uint32 sequence number"
    seq_no: FloatFilter
    split: FloatFilter
    "- 0 – none\n- 2 – split\n- 3 – merge"
    split_type: IntFilter
    split_type_name: SplitTypeEnumFilter
    "Logical time of the shardchain start"
    start_lt: StringFilter
    want_merge: BooleanFilter
    want_split: BooleanFilter
    OR: BlockMasterShardHashesDescrFilter
}

input BlockMasterShardHashesFilter {
    "Shard description"
    descr: BlockMasterShardHashesDescrFilter
    "Shard ID"
    shard: StringFilter
    "Uint32 workchain ID"
    workchain_id: IntFilter
    OR: BlockMasterShardHashesFilter
}

input BlockMasterShardFeesFilter {
    "Amount of fees created during shard"
    create: StringFilter
    "Amount of non gram fees created in non gram crypto currencies during the block."
    create_other: OtherCurrencyArrayFilter
    "Amount of fees in grams"
    fees: StringFilter
    "Array of fees in non gram crypto currencies"
    fees_other: OtherCurrencyArrayFilter
    shard: StringFilter
    workchain_id: IntFilter
    OR: BlockMasterShardFeesFilter
}

input BlockMasterPrevBlkSignaturesFilter {
    node_id: StringFilter
    r: StringFilter
    s: StringFilter
    OR: BlockMasterPrevBlkSignaturesFilter
}

input BlockMasterPrevBlkSignaturesArrayFilter {
    any: BlockMasterPrevBlkSignaturesFilter
    all: BlockMasterPrevBlkSignaturesFilter
}

input BlockMasterShardFeesArrayFilter {
    any: BlockMasterShardFeesFilter
    all: BlockMasterShardFeesFilter
}

input BlockMasterShardHashesArrayFilter {
    any: BlockMasterShardHashesFilter
    all: BlockMasterShardHashesFilter
}

input BlockMasterFilter {
    config: ConfigFilter
    config_addr: StringFilter
    "Max block generation time of shards"
    max_shard_gen_utime: FloatFilter
    "Min block generation time of shards"
    min_shard_gen_utime: FloatFilter
    prev_blk_signatures: BlockMasterPrevBlkSignaturesArrayFilter
    recover_create_msg: InMsgFilter
    shard_fees: BlockMasterShardFeesArrayFilter
    shard_hashes: BlockMasterShardHashesArrayFilter
    OR: BlockMasterFilter
}

input BlockSignaturesSignaturesFilter {
    node_id: StringFilter
    "'R' part of signature"
    r: StringFilter
    "'s' part of signature"
    s: StringFilter
    OR: BlockSignaturesSignaturesFilter
}

input ZerostateMasterFilter {
    config: ConfigFilter
    config_addr: StringFilter
    "Overall balance of all accounts"
    global_balance: StringFilter
    "Overall balance of all accounts in other currencies"
    global_balance_other: OtherCurrencyArrayFilter
    validator_list_hash_short: FloatFilter
    OR: ZerostateMasterFilter
}

input AccountStatusEnumFilter {
    eq: AccountStatusEnum
    ne: AccountStatusEnum
    gt: AccountStatusEnum
    lt: AccountStatusEnum
    ge: AccountStatusEnum
    le: AccountStatusEnum
    in: [AccountStatusEnum]
    notIn: [AccountStatusEnum]
}

input ZerostateAccountsFilter {
    id: StringFilter
    "Returns the current status of the account.\n```\n{\n  accounts(filter: {acc_type:{eq:1}}){\n    id\n    acc_type\n  }\n}\n```\n        \n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist"
    acc_type: IntFilter
    acc_type_name: AccountStatusEnumFilter
    "```\n{\n  accounts(orderBy:{path:\"balance\",direction:DESC}){\n    balance\n  }\n}\n```"
    balance: StringFilter
    balance_other: OtherCurrencyArrayFilter
    "Contains sum of all the bits used by the cells of the account. Used in storage fee calculation"
    bits: StringFilter
    "Bag of cells with the account struct encoded as base64."
    boc: StringFilter
    "Contains number of the cells of the account. Used in storage fee calculation"
    cells: StringFilter
    "If present, contains smart-contract code encoded with in base64.\n```  \n{\n  accounts (filter:{code:{eq:null}}){\n    id\n    acc_type\n  }\n}   \n```          "
    code: StringFilter
    "`code` field root hash."
    code_hash: StringFilter
    "If present, contains smart-contract data encoded with in base64."
    data: StringFilter
    "`data` field root hash."
    data_hash: StringFilter
    "If present, accumulates the storage payments that could not be exacted from the balance of the account, represented by a strictly positive amount of nano tokens; it can be present only for uninitialized or frozen accounts that have a balance of zero Grams (but may have non-zero balances in non gram cryptocurrencies). When due_payment becomes larger than the value of a configurable parameter of the blockchain, the ac- count is destroyed altogether, and its balance, if any, is transferred to the zero account.\n```\n{\n  accounts(filter: { due_payment: { ne: null } })\n    {\n      id\n    }\n}\n```"
    due_payment: StringFilter
    "account 's initial code hash (when it was deployed)"
    init_code_hash: StringFilter
    "Contains either the unixtime of the most recent storage payment\ncollected (usually this is the unixtime of the most recent transaction),\nor the unixtime when the account was created (again, by a transaction).\n```\nquery{\n  accounts(filter: {\n    last_paid:{ge:1567296000}\n  }) {\n  id\n  last_paid}\n}\n```     "
    last_paid: FloatFilter
    last_trans_lt: StringFilter
    "If present, contains library code used in smart-contract."
    library: StringFilter
    "`library` field root hash."
    library_hash: StringFilter
    prev_code_hash: StringFilter
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64."
    proof: StringFilter
    "Contains the number of public cells of the account. Used in storage fee calculation."
    public_cells: StringFilter
    "Is present and non-zero only in instances of large smart contracts."
    split_depth: IntFilter
    "Contains the representation hash of an instance of `StateInit` when an account is frozen."
    state_hash: StringFilter
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function."
    tick: BooleanFilter
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.\n```        \n{\n  accounts (filter:{tock:{ne:null}}){\n    id\n    tock\n    tick\n  }\n}\n```"
    tock: BooleanFilter
    "Workchain id of the account address (id field)."
    workchain_id: IntFilter
    OR: ZerostateAccountsFilter
}

input ZerostateLibrariesFilter {
    "Library hash"
    hash: StringFilter
    "Serialized bag of cells of this library encoded with base64"
    lib: StringFilter
    "List of the accounts which use the library"
    publishers: StringArrayFilter
    OR: ZerostateLibrariesFilter
}

"# Account type\n\nRecall that a smart contract and an account are the same thing in the context\nof the TON Blockchain, and that these terms can be used interchangeably, at\nleast as long as only small (or “usual”) smart contracts are considered. A large\nsmart-contract may employ several accounts lying in different shardchains of\nthe same workchain for load balancing purposes.\n\nAn account is identified by its full address and is completely described by\nits state. In other words, there is nothing else in an account apart from its\naddress and state."
input AccountFilter {
    id: StringFilter
    "Returns the current status of the account.\n```\n{\n  accounts(filter: {acc_type:{eq:1}}){\n    id\n    acc_type\n  }\n}\n```\n        \n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist"
    acc_type: IntFilter
    acc_type_name: AccountStatusEnumFilter
    "```\n{\n  accounts(orderBy:{path:\"balance\",direction:DESC}){\n    balance\n  }\n}\n```"
    balance: StringFilter
    balance_other: OtherCurrencyArrayFilter
    "Contains sum of all the bits used by the cells of the account. Used in storage fee calculation"
    bits: StringFilter
    "Bag of cells with the account struct encoded as base64."
    boc: StringFilter
    "Contains number of the cells of the account. Used in storage fee calculation"
    cells: StringFilter
    "If present, contains smart-contract code encoded with in base64.\n```  \n{\n  accounts (filter:{code:{eq:null}}){\n    id\n    acc_type\n  }\n}   \n```          "
    code: StringFilter
    "`code` field root hash."
    code_hash: StringFilter
    "If present, contains smart-contract data encoded with in base64."
    data: StringFilter
    "`data` field root hash."
    data_hash: StringFilter
    "If present, accumulates the storage payments that could not be exacted from the balance of the account, represented by a strictly positive amount of nano tokens; it can be present only for uninitialized or frozen accounts that have a balance of zero Grams (but may have non-zero balances in non gram cryptocurrencies). When due_payment becomes larger than the value of a configurable parameter of the blockchain, the ac- count is destroyed altogether, and its balance, if any, is transferred to the zero account.\n```\n{\n  accounts(filter: { due_payment: { ne: null } })\n    {\n      id\n    }\n}\n```"
    due_payment: StringFilter
    "account 's initial code hash (when it was deployed)"
    init_code_hash: StringFilter
    "Contains either the unixtime of the most recent storage payment\ncollected (usually this is the unixtime of the most recent transaction),\nor the unixtime when the account was created (again, by a transaction).\n```\nquery{\n  accounts(filter: {\n    last_paid:{ge:1567296000}\n  }) {\n  id\n  last_paid}\n}\n```     "
    last_paid: FloatFilter
    last_trans_lt: StringFilter
    "If present, contains library code used in smart-contract."
    library: StringFilter
    "`library` field root hash."
    library_hash: StringFilter
    prev_code_hash: StringFilter
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64."
    proof: StringFilter
    "Contains the number of public cells of the account. Used in storage fee calculation."
    public_cells: StringFilter
    "Is present and non-zero only in instances of large smart contracts."
    split_depth: IntFilter
    "Contains the representation hash of an instance of `StateInit` when an account is frozen."
    state_hash: StringFilter
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function."
    tick: BooleanFilter
    "May be present only in the masterchain—and within the masterchain, only in some fundamental smart contracts required for the whole system to function.\n```        \n{\n  accounts (filter:{tock:{ne:null}}){\n    id\n    tock\n    tick\n  }\n}\n```"
    tock: BooleanFilter
    "Workchain id of the account address (id field)."
    workchain_id: IntFilter
    OR: AccountFilter
}

input MessageArrayFilter {
    any: MessageFilter
    all: MessageFilter
}

input TransactionProcessingStatusEnumFilter {
    eq: TransactionProcessingStatusEnum
    ne: TransactionProcessingStatusEnum
    gt: TransactionProcessingStatusEnum
    lt: TransactionProcessingStatusEnum
    ge: TransactionProcessingStatusEnum
    le: TransactionProcessingStatusEnum
    in: [TransactionProcessingStatusEnum]
    notIn: [TransactionProcessingStatusEnum]
}

input TransactionTypeEnumFilter {
    eq: TransactionTypeEnum
    ne: TransactionTypeEnum
    gt: TransactionTypeEnum
    lt: TransactionTypeEnum
    ge: TransactionTypeEnum
    le: TransactionTypeEnum
    in: [TransactionTypeEnum]
    notIn: [TransactionTypeEnum]
}

"TON Transaction"
input TransactionFilter {
    id: StringFilter
    aborted: BooleanFilter
    account: AccountFilter
    account_addr: StringFilter
    action: TransactionActionFilter
    "Account balance change after the transaction.\nBecause fwd_fee is collected by the validators of the receiving shard, \ntotal_fees value does not include Sum(out_msg.fwd_fee[]), but includes in_msg.fwd_fee.\n\nThe formula is:\nbalance_delta = in_msg.value - total_fees - Sum(out_msg.value[]) - Sum(out_msg.fwd_fee[])"
    balance_delta: StringFilter
    "Account balance change after the transaction.\nBecause fwd_fee is collected by the validators of the receiving shard, \ntotal_fees value does not include Sum(out_msg.fwd_fee[]), but includes in_msg.fwd_fee.\n\nThe formula is:\nbalance_delta = in_msg.value - total_fees - Sum(out_msg.value[]) - Sum(out_msg.fwd_fee[])"
    balance_delta_other: OtherCurrencyArrayFilter
    block: BlockFilter
    block_id: StringFilter
    boc: StringFilter
    bounce: TransactionBounceFilter
    "Collection-unique field for pagination and sorting. This field is designed to retain logical order."
    chain_order: StringFilter
    compute: TransactionComputeFilter
    credit: TransactionCreditFilter
    credit_first: BooleanFilter
    destroyed: BooleanFilter
    "The end state of an account after a transaction, 1 is returned to indicate a finalized transaction at an active account\n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist"
    end_status: IntFilter
    end_status_name: AccountStatusEnumFilter
    "Fee for inbound external message import."
    ext_in_msg_fee: StringFilter
    in_message: MessageFilter
    in_msg: StringFilter
    installed: BooleanFilter
    "Logical time. A component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see [the TON blockchain specification](https:\/\/test.ton.org\/tblkch.pdf)."
    lt: StringFilter
    "Merkle update field"
    new_hash: StringFilter
    now: FloatFilter
    "Merkle update field"
    old_hash: StringFilter
    "The initial state of account. Note that in this case the query may return 0, if the account was not active before the transaction and 1 if it was already active\n- 0 – uninit\n- 1 – active\n- 2 – frozen\n- 3 – nonExist"
    orig_status: IntFilter
    orig_status_name: AccountStatusEnumFilter
    out_messages: MessageArrayFilter
    out_msgs: StringArrayFilter
    "The number of generated outbound messages (one of the common transaction parameters defined by the specification)"
    outmsg_cnt: IntFilter
    prepare_transaction: StringFilter
    prev_trans_hash: StringFilter
    prev_trans_lt: StringFilter
    proof: StringFilter
    split_info: TransactionSplitInfoFilter
    "Transaction processing status\n- 0 – unknown\n- 1 – preliminary\n- 2 – proposed\n- 3 – finalized\n- 4 – refused"
    status: IntFilter
    status_name: TransactionProcessingStatusEnumFilter
    storage: TransactionStorageFilter
    "Total amount of fees collected by the validators. \nBecause fwd_fee is collected by the validators of the receiving shard, \ntotal_fees value does not include Sum(out_msg.fwd_fee[]), but includes in_msg.fwd_fee.\nThe formula is:\ntotal_fees = in_msg.value - balance_delta - Sum(out_msg.value[]) - Sum(out_msg.fwd_fee[])"
    total_fees: StringFilter
    "Same as above, but reserved for non gram coins that may appear in the blockchain"
    total_fees_other: OtherCurrencyArrayFilter
    "Transaction type according to the original blockchain specification, clause 4.2.4.\n- 0 – ordinary\n- 1 – storage\n- 2 – tick\n- 3 – tock\n- 4 – splitPrepare\n- 5 – splitInstall\n- 6 – mergePrepare\n- 7 – mergeInstall"
    tr_type: IntFilter
    tr_type_name: TransactionTypeEnumFilter
    tt: StringFilter
    "Workchain id of the account address (account_addr field)"
    workchain_id: IntFilter
    OR: TransactionFilter
}

input MessageTypeEnumFilter {
    eq: MessageTypeEnum
    ne: MessageTypeEnum
    gt: MessageTypeEnum
    lt: MessageTypeEnum
    ge: MessageTypeEnum
    le: MessageTypeEnum
    in: [MessageTypeEnum]
    notIn: [MessageTypeEnum]
}

input MessageProcessingStatusEnumFilter {
    eq: MessageProcessingStatusEnum
    ne: MessageProcessingStatusEnum
    gt: MessageProcessingStatusEnum
    lt: MessageProcessingStatusEnum
    ge: MessageProcessingStatusEnum
    le: MessageProcessingStatusEnum
    in: [MessageProcessingStatusEnum]
    notIn: [MessageProcessingStatusEnum]
}

"# Message type\n\nMessage layout queries.  A message consists of its header followed by its\nbody or payload. The body is essentially arbitrary, to be interpreted by the\ndestination smart contract. It can be queried with the following fields:"
input MessageFilter {
    id: StringFilter
    block: BlockFilter
    "Merkle proof that account is a part of shard state it cut from as a bag of cells with Merkle proof struct encoded as base64."
    block_id: StringFilter
    "A bag of cells with the message structure encoded as base64."
    boc: StringFilter
    "Bag of cells with the message body encoded as base64."
    body: StringFilter
    "`body` field root hash."
    body_hash: StringFilter
    "Bounce flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender."
    bounce: BooleanFilter
    "Bounced flag. If the transaction has been aborted, and the inbound message has its bounce flag set, then it is “bounced” by automatically generating an outbound message (with the bounce flag clear) to its original sender."
    bounced: BooleanFilter
    "Collection-unique field for pagination and sorting. This field is designed to retain logical output order (for logical input order use transaction.in_message)."
    chain_order: StringFilter
    "Represents contract code in deploy messages."
    code: StringFilter
    "`code` field root hash."
    code_hash: StringFilter
    "Creation unixtime automatically set by the generating transaction. The creation unixtime equals the creation unixtime of the block containing the generating transaction."
    created_at: FloatFilter
    "Logical creation time automatically set by the generating transaction."
    created_lt: StringFilter
    "Represents initial data for a contract in deploy messages"
    data: StringFilter
    "`data` field root hash."
    data_hash: StringFilter
    "Returns destination address string"
    dst: StringFilter
    dst_account: AccountFilter
    dst_transaction: TransactionFilter
    "Workchain id of the destination address (dst field)"
    dst_workchain_id: IntFilter
    "Original total forwarding fee paid for using the HR mechanism; it is automatically computed from some configuration parameters and the size of the message at the time the message is generated."
    fwd_fee: StringFilter
    "IHR is disabled for the message."
    ihr_disabled: BooleanFilter
    "This value is subtracted from the value attached to the message and awarded to the validators of the destination shardchain if they include the message by the IHR mechanism."
    ihr_fee: StringFilter
    import_fee: StringFilter
    "Represents contract library in deploy messages"
    library: StringFilter
    "`library` field root hash."
    library_hash: StringFilter
    "Returns the type of message.\n- 0 – internal\n- 1 – extIn\n- 2 – extOut"
    msg_type: IntFilter
    msg_type_name: MessageTypeEnumFilter
    "Merkle proof that message is a part of a block it cut from. It is a bag of cells with Merkle proof struct encoded as base64."
    proof: StringFilter
    "This is only used for special contracts in masterchain to deploy messages."
    split_depth: IntFilter
    "Returns source address string"
    src: StringFilter
    src_account: AccountFilter
    src_transaction: TransactionFilter
    "Workchain id of the source address (src field)"
    src_workchain_id: IntFilter
    "Returns internal processing status according to the numbers shown.\n- 0 – unknown\n- 1 – queued\n- 2 – processing\n- 3 – preliminary\n- 4 – proposed\n- 5 – finalized\n- 6 – refused\n- 7 – transiting"
    status: IntFilter
    status_name: MessageProcessingStatusEnumFilter
    "This is only used for special contracts in masterchain to deploy messages."
    tick: BooleanFilter
    "This is only used for special contracts in masterchain to deploy messages"
    tock: BooleanFilter
    "May or may not be present"
    value: StringFilter
    "May or may not be present."
    value_other: OtherCurrencyArrayFilter
    OR: MessageFilter
}

input BlockAccountBlocksArrayFilter {
    any: BlockAccountBlocksFilter
    all: BlockAccountBlocksFilter
}

input InMsgArrayFilter {
    any: InMsgFilter
    all: InMsgFilter
}

input OutMsgArrayFilter {
    any: OutMsgFilter
    all: OutMsgFilter
}

input BlockProcessingStatusEnumFilter {
    eq: BlockProcessingStatusEnum
    ne: BlockProcessingStatusEnum
    gt: BlockProcessingStatusEnum
    lt: BlockProcessingStatusEnum
    ge: BlockProcessingStatusEnum
    le: BlockProcessingStatusEnum
    in: [BlockProcessingStatusEnum]
    notIn: [BlockProcessingStatusEnum]
}

"This is Block"
input BlockFilter {
    id: StringFilter
    account_blocks: BlockAccountBlocksArrayFilter
    after_merge: BooleanFilter
    after_split: BooleanFilter
    before_split: BooleanFilter
    "Serialized bag of cells of this block encoded with base64"
    boc: StringFilter
    "Collection-unique field for pagination and sorting. This field is designed to retain logical order."
    chain_order: StringFilter
    "Public key of the collator who produced this block."
    created_by: StringFilter
    "Logical creation time automatically set by the block formation end."
    end_lt: StringFilter
    "Block file hash"
    file_hash: StringFilter
    flags: IntFilter
    gen_catchain_seqno: FloatFilter
    gen_software_capabilities: StringFilter
    gen_software_version: FloatFilter
    "uint 32 generation time stamp"
    gen_utime: FloatFilter
    gen_validator_list_hash_short: FloatFilter
    "uint32 global block ID"
    global_id: IntFilter
    in_msg_descr: InMsgArrayFilter
    "true if this block is a key block"
    key_block: BooleanFilter
    master: BlockMasterFilter
    master_ref: ExtBlkRefFilter
    "Returns last known master block at the time of shard generation."
    min_ref_mc_seqno: FloatFilter
    out_msg_descr: OutMsgArrayFilter
    "External block reference for previous block in case of shard merge."
    prev_alt_ref: ExtBlkRefFilter
    "Returns a number of a previous key block."
    prev_key_block_seqno: FloatFilter
    "External block reference for previous block."
    prev_ref: ExtBlkRefFilter
    prev_vert_alt_ref: ExtBlkRefFilter
    "External block reference for previous block in case of vertical blocks."
    prev_vert_ref: ExtBlkRefFilter
    rand_seed: StringFilter
    seq_no: FloatFilter
    shard: StringFilter
    signatures: BlockSignaturesFilter
    "Logical creation time automatically set by the block formation start.\nLogical time is a component of the TON Blockchain that also plays an important role in message delivery is the logical time, usually denoted by Lt. It is a non-negative 64-bit integer, assigned to certain events. For more details, see the TON blockchain specification"
    start_lt: StringFilter
    state_update: BlockStateUpdateFilter
    "Returns block processing status\n- 0 – unknown\n- 1 – proposed\n- 2 – finalized\n- 3 – refused"
    status: IntFilter
    status_name: BlockProcessingStatusEnumFilter
    tr_count: IntFilter
    value_flow: BlockValueFlowFilter
    "uin32 block version identifier"
    version: FloatFilter
    vert_seq_no: FloatFilter
    want_merge: BooleanFilter
    want_split: BooleanFilter
    "uint32 workchain identifier"
    workchain_id: IntFilter
    OR: BlockFilter
}

input BlockSignaturesSignaturesArrayFilter {
    any: BlockSignaturesSignaturesFilter
    all: BlockSignaturesSignaturesFilter
}

"Set of validator's signatures for the Block with correspond id"
input BlockSignaturesFilter {
    id: StringFilter
    block: BlockFilter
    catchain_seqno: FloatFilter
    "Signed block's gen_utime"
    gen_utime: FloatFilter
    "Signed block's merkle proof"
    proof: StringFilter
    "Signed block's seq_no"
    seq_no: FloatFilter
    "Signed block's shard"
    shard: StringFilter
    sig_weight: StringFilter
    "Array of signatures from block's validators"
    signatures: BlockSignaturesSignaturesArrayFilter
    validator_list_hash_short: FloatFilter
    "Signed block's workchain_id"
    workchain_id: IntFilter
    OR: BlockSignaturesFilter
}

input ZerostateAccountsArrayFilter {
    any: ZerostateAccountsFilter
    all: ZerostateAccountsFilter
}

input ZerostateLibrariesArrayFilter {
    any: ZerostateLibrariesFilter
    all: ZerostateLibrariesFilter
}

"The initial state of the workchain before first block was generated"
input ZerostateFilter {
    id: StringFilter
    "Initial accounts state at the workchain start"
    accounts: ZerostateAccountsArrayFilter
    "Serialized bag of cells of this zerostate encoded with base64"
    boc: StringFilter
    "Zerostate file hash"
    file_hash: StringFilter
    "uint32 global network ID"
    global_id: IntFilter
    "Initial libraries at the workchain start"
    libraries: ZerostateLibrariesArrayFilter
    master: ZerostateMasterFilter
    "Zerostate root cell representation hash"
    root_hash: StringFilter
    "Overall balance of all accounts of the workchain"
    total_balance: StringFilter
    "Overall balance of all accounts of the workchain in other currencies"
    total_balance_other: OtherCurrencyArrayFilter
    "Zerostate workchain_id"
    workchain_id: IntFilter
    OR: ZerostateFilter
}

"Specify sort order direction"
enum QueryOrderByDirection {
    "Documents will be sorted in ascended order (e.g. from A to Z)"
    ASC
    "Documents will be sorted in descendant order (e.g. from Z to A)"
    DESC
}

"Specify how to sort results.\nYou can sort documents in result set using more than one field."
input QueryOrderBy {
    "Path to field which must be used as a sort criteria.\nIf field resides deep in structure path items must be separated with dot (e.g. \"foo.bar.baz\")."
    path: String
    "Sort order direction"
    direction: QueryOrderByDirection
}

"Counterparty\n\nComplexity 20"
type Counterparty {
    "\nComplexity 0"
    account: String
    "\nComplexity 0"
    counterparty: String
    "\nComplexity 0"
    last_message_at: Float
    "\nComplexity 0"
    last_message_id: String
    "\nComplexity 0"
    last_message_is_reverse: Boolean
    "\nComplexity 0"
    last_message_value(format: BigIntFormat): String
    "\nComplexity 0"
    cursor: String
}

input CounterpartyFilter {
    account: StringFilter
    counterparty: StringFilter
    last_message_at: FloatFilter
    last_message_id: StringFilter
    last_message_is_reverse: BooleanFilter
    last_message_value: StringFilter
}

enum RempReceiptKind {
    RejectedByFullnode
    SentToValidators
    IncludedIntoBlock
    IncludedIntoAcceptedBlock
    Finalized
    Other
}

scalar RempReceiptJson

"\nComplexity 10"
type RempReceipt {
    kind: RempReceiptKind!
    "\nComplexity 0"
    messageId: String!
    "\nComplexity 0"
    timestamp: Float!
    "\nComplexity 0"
    json: RempReceiptJson!
}

"Request with external inbound message"
input Request {
    "256-bit Hash of message in base64"
    id: String
    "Serialized message in base64"
    body: String
    "Message expiration time (unix time in ms)"
    expireAt: Float
}

"Aggregation function used to collect aggregated value"
enum AggregationFn {
    "Returns count of filtered record"
    COUNT
    "Returns the minimal value for a field in filtered records"
    MIN
    "Returns the maximal value for a field in filtered records"
    MAX
    "Returns a sum of values for a field in filtered records"
    SUM
    "Returns an average value for a field in filtered records"
    AVERAGE
}

"Specify field and aggregation function used to collect aggregated value"
input FieldAggregation {
    "Dot separated path to field. Can be omitted for COUNT fn."
    field: String
    "Aggregation function. Default value is COUNT."
    fn: AggregationFn
}

enum CacheControlScope {
    PUBLIC
    PRIVATE
}

"The `Upload` scalar type represents a file upload."
scalar Upload

input MessageMonitoringParams {
    "TVM hash of the message BOC"
    hash: String
    "Destination address of the external inbound message"
    address: String
    "Message BOC in base64, needed to resolve an error in case of failed message processing"
    boc: String
    "Wait for message finalization until waitUntil shard block time in UNIX time"
    waitUntil: Int!
}

"\nComplexity 10"
type MessageMonitoringResult {
    "TVM hash of the message BOC\n\nComplexity 0"
    hash: String!
    "Shows message status, if it was or was not finalized until waitUntil block time"
    status: RecentExtInMsgStatusType!
    "Contains transaction.\nIn case of FINALIZED the transaction is extracted from the block.\nIn case of TIMEOUT the transaction is emulated using last known\naccount state.\nCan be Null in case of emulation on non-existing account."
    transaction: RecentExtInMsgTransaction
    "Contains an error message in case when status is TIMEOUT\n\nComplexity 0"
    error: String
}

enum RecentExtInMsgStatusType {
    "Returned when the message was processed and included into finalized block before waitUntil block time"
    FINALIZED
    "Returned when the message was not processed until waitUntil block time"
    TIMEOUT
    "Reserved for future statuses. Is never returned."
    RESERVED
}

"\nComplexity 0"
type RecentExtInMsgTransaction {
    "\nComplexity 0"
    hash: String
    "\nComplexity 0"
    aborted: Boolean!
    compute: RecentExtInMsgTransactionCompute
}

"\nComplexity 0"
type RecentExtInMsgTransactionCompute {
    "\nComplexity 0"
    exit_code: Int!
}

"\nComplexity 0"
type Cost {
    "\nComplexity 0"
    complexity: Int
    "\nComplexity 0"
    explain: [String]
}

"\nComplexity 0"
type Price {
    price: EverPrice!
    marketCap: EverMarketCap!
    volume: EverVolume!
    "\nComplexity 0"
    updatedAt: Float!
    "\nComplexity 0"
    updatedISO: String!
}

"\nComplexity 10"
type EverPrice {
    "\nComplexity 0"
    usd: Float!
}

"\nComplexity 10"
type EverMarketCap {
    "\nComplexity 0"
    usd: Float!
}

"\nComplexity 10"
type EverVolume {
    "\nComplexity 0"
    usd: Float!
}